MODEL  800               // Tell TxBasic which model we're using              |
//----------------------------------------------------------------------------<
//
//                           Profiling Sonde Platform
                             VERSION$  = "3.37"
                             FILE_MODIFIED = 201204??
                             deBug = 1 // Toggles deBug mode for printing to COM1
                                       // (0 = almost silent, 1 = Some messages, 2 = All Messages (SETUP3.INI))
IFF 0 // Just lets me collapse all the comments in Notepad++
//   ISSUES:
//       rarely crashes to Tom8 FOR NO APPARENT REASON!
//       Sometimes casts are skipped in the morning when log file takes too long to upload.
//   Future Upgrades:
//      Ability to send sonde to depth: down 200cm would go to 200cm deep.
//      When lowering to waterline, look for change in depth as well as absolute values.
//      Add to up and down commands ability to set flags (check_WL, check_cond) and go to specific depths
//      Rather than use dummy values (e.g. 9.99 and -88.8, implement a data quality variable to mark depth, conductivity as good or bad
//      Clicks per m is non-linear. If we keep two click counters, the current one, and an overall. Could we easily make CLICKS_PER_M non-linear?
//      If the download script sees a cast begin, it should hang up and try again in 5 minutes.
//   Programming Conventions:
//       All variables in TxBasic are GLOBAL!
//       variables are lower_case, CONSTANTS are UPPER_CASE, sub routines: are CamelCase
//       CONSTANTS may be changed to values stored in setup3.ini
//       Depths are in meters unless otherwise noted.
//       temp_* variables should not be used across subroutines.
//       Variables used in a subroutine should be noted in the header. It should be noted if they are only used locally, read only, or modified.
//   Changes:
//      2012-04-?? Version 3.37 (xxxx bytes)
//           Both loops in CheckSMS can be exited with esc or crtl-x
//           ISCO schedule was being read twice on startup
//      2012-04-19 Version 3.36 (37,216 bytes)
//           Fixed problem with SMS messages.
//      2012-04-18 Version 3.35 (37,272 bytes)
//           Added support for 6600 with pH
//           Added SONDE_PARA and new line to cast header.
//           In places where there was a STORE and a concatenation of sms_msg, their messages were combined to save space.
//           Replaced most calls to VGET(1) with PROFILER_NUMBER
//      2012-01-23 Version 3.34 (37,380 bytes)
//           Using results of para in InitializeSonde to seup up parsing variables.
//             In this way we now handle different instrument sets
//           SONDE_FILTERING now 1 or 0 rather than "T" or "F"
//           If SONDE_ID is blank, it is no longer set to SONDE_SN
//           Sonde is initialized before ini file is read.
//           ini variable AVP_SENSOR_CONFIG no longer used. Will be phased out
//           Moved some actions from ParseVariables to ReadSetupIni
//           Added sinit command to console to re-initialize sonde. New avp_help.txt
//           OpenPort no longer clears input variables when done.
//      2012-01-19 Version 3.33 (37,327 bytes)
//           New verson 3.10 software on older sondes changes output offsets. Program now looks for last three characters in SONDE_ID
//           Removed SONDE_CAGE_LEN. Need to increase DEPTH_MARGIN_M by 0.25m
//           Added ISCOClearSched & ISCOscheduleProcess
//           Set ISCO_bottle and EEPROM register 2 to 0 when reading schedule or finished with all bottles.
//           If no isco_sch.txt is found, clears ISCO schedule, but no longer sets ISCO_ENABLED to 0. This way we can do manual samplings.
//           No initial SMS after restart. Modem wasn't ready.
//      2011-12-05 Version 3.32 (37,291 bytes)
//           Removed a superfluous RETURN in ISCOcheck.
//           Remove potential infinite loop in StopNow if Ctrl-c is pressed at the wrong time in Stoppage while sonde is sampling.
//      2011-10-11 Version 3.31 (xxxxx bytes)
//           Fixed bug where if there are never any pings, cast depth is hard coded rather than from ini file.
//           Added CalculatedepthTarget subroutine
//           Removed variables which stored highest and lowest depth values seen to save room.
//           Split ProcessDepth off of GetDepth for clarity
//           Added "Command:" back at end of cast.
//      2011-09-19 Version 3.30 (37,489 bytes) based on 3.26
//           Removed call to ResetWatchdogTimer from within GetDepth WHILE loop.
//           Reduced DEPTH_TIMEOUT from 14 seconds to 6 seconds
//           Changed end of cast behavior on an aborted cast.
//           Comment cleanup
//           SendSMS changed to CheckSMS. Can be called even if there is no SMS message
//      Versions 2.27 * 2.28 were an attempt to put the initialization of variables in a subroutine.
//           TxBasic would crash to tom8 when attempting to burn these so they were abandoned.
//      2011-06-13 Version 3.26 (XXXXX bytes)
//           Better handling of limit switch during backwind code.
//           Added a GOTOs in CheckSondeCalibration to make sure calibration worked.
//           Added CalibrateSonde as its own subroutine.
//           Fixed problem with aborting casts.
//      2011-04-05 Version 3.25 (37,390 bytes)
//           Added wind data to console status message.
//           Simplified the way in which sonde_depth_max is reset in GetSondeDepth.
//           Variable sonde_depth_max is reset in StartSondeSampling. Removed sonde_clicks_max_depth variable.
//           Added clicks and depth to Delta D message.
//           Added sonde_depth_delta! locally in MotorRun
//      2010-03-31 Version 3.24 (37,418 bytes)
//           Altered console help. Need to load new avp_help.txt file
//           Click count for backwind checking is reset everytime there is a new maximum sonde depth.
//              This should allow much smaller DELTA_CLICKS values.
//           Added ClearSched subroutine.
//           Limit switch on backwind clears schedule and sends SMS
//           Changed DeltaD backwind check from a print to a store.
//           Need to adjust backwind sensitivity based upon wind speed.
//      2010-10-04 Version 3.23 (37,424 bytes)
//           Added sonde_samples
//           Wind variables (except wind_samples) are reset at beginning of cast) in GetWindData rather than at end.
//           saltwater_cond is set every cast to half the value seen at LanunchCheck Depth.
//           Simplified code which parses sonde_conduct and sonde_chlor.
//           Conductivity is always parsed when possible
//           No longer disables ISCO when all bottles are full.
//      2010-08-22 Version 3.22 (37,349? bytes)
//           MotorRun only clears sonde buffer if sonde_logging = 'F'. This allows us to start the data logging early.
//           Reduced post-cast wait period from 10 to 8 seconds. We were getting more data at the end than we needed.
//           Fixed some log messages during ISCO cast.
//           Fixed interger to float conversion which was causing ISCO cast depths to be rounded off to nearest meter.
//      2010-07-14 Version 3.21 (37,390 bytes)
//           current_idle! set in ReadSetupIni. (un-does change from 3.18)
//           IF SONDE_FILTERING, an extra 10 seconds of samples are collected at the beginning and end of each cast.
//           Added PCLR 2 to StopNow so we never exit with the watchdog disabled.
//           Sometimes the wind instrument puts an extra character in V1-V4 leading to parsing problems...
//               Made changes to parsing wind_speed_sample & ParseWindData to account for this
//      2010-05-21 Version 3.20 (37,131 bytes)
//           Added quitprog console command.
//           Fixed bug instroduced in 3.18 where filter status and voltage are in the body of the cast data, not the header.
//           removed REHOME_TRIES
//           Added set functionality to console and var_help.txt file.
//      2010-05-20 Version 3.19 (37,493 bytes)
//           Changed ReHome to ParkSonde at end of ISCO cast and if cast starts with sonde not fully retrieved.
//           Start depth sampling a little earlier.
//           Fixed wrong comparison in PTC/backwind code
//           Fixed bug which caused "help" not to work in console mode.
//      2010-05-14 Version 3.18 (37,438 bytes)
//           Shortened MANY strings to reduce file size.
//           current_idle only set on startup, not after every cast.
//           Low current messages report the current.
//           On relay trip, rewind is not done in console mode.
//           Added tail command.
//           Moved the portion of the dat header which records voltage to the end of the down cast.
//      2010-04-29 Version 3.17 (38,491 bytes)
//           Some changes to MotorWatcher and LowCurrent where the motor is turned off before a message is generated.
//           Fixed Parsing in PartialDL
//           At end of cast reverted to doing calibration after final wind buffer empty. Might have been filling the buffer.
//           Added PTC_CURRENT_MIN! and PTC_CURRENT_MAX! to SETUP3.INI. NOTE: The default values are for the New River!
//           Based on Empirical testing, the folowing values should work for these PTCs:
//              MF-R180   .3A MAX .07A Min
//              MF-R250   .5A MAX .12A Min
//      2010-04-06 Version 3.16 (38,416 bytes)
//           Console commands are stored, but not echoed.
//           Raised PTC currents.
//           If equipped with limit relay, there is no AMPS_LOW functionality in MotorWatcher
//           "Probable electrical fault" is now printed rather than stored.
//           Cleaned up some code where temp variables were used and two lines could be combined. If it works, code marked REMOVE can be purged.
//           ParkSonde no longer leaves sonde turned off
//           At end of cast, calibration is done before final wind buffer empty. This gives us more samples.
//           CheckSondeCalibration no longer stops sonde at end by default.
//           Check_WL is always set to 0 by MotorDown.
//           Changes to WaterLineDock: use INRUSH_CLICKS for WaterLineDock instead of 2, use conductivity as a condition.
//      2010-04-01 Version 3.15  (38,549 bytes)
//           Changed default retrieve_count to 999
//           Alter INRUSH_CLICKS if we have the relay motor board.
//           Added ability to turn off encoder when moving manually winch
//           Motor doesn't stop on "Probable electrical fault" until clicker times out.
//           Changed MAX_TIDE_D from 0.03 to 0.3 meters.
//           Fixed logic error in abnormal depth routine
//           Changed pause in StartSondeSampling while starting sampling from 50 to 100.
//      2010-03-30 Version 3.14 (38,492 bytes)
//           Added ResetWatchDogTimer in loop which tries to establish communications with sonde.
//           Added AVP_LIMIT_RELAY to indicate platform has a limit switch and relay on the winch. Set in SETUP3.INI
//           Added code in MotorWatcher for relay trip
//           EncoderOff no longer makes sure motor is off since we now want to run the motor briefly with the encoder off.
//           Added PTC_CURRENT_MIN! and PTC_CURRENT_MAX!
//           Added LowCurrent subroutine.
//      2010-03-10 Version 3.13 (38,070 bytes)
//           Fixed a bug in MotorWatcher where program could get stuck.
//           To enter consle the 1st time you need to press esc or ctrl-x rather than "any key".
//              This is to prevent stuff from the modem from putting us in console mode and delaying startup.
//      2010-03-05 Version 3.12 (37,922 bytes)
//           Added DELTA_CLICKS to SETUP3.ini. Platforms in rougher waters will need higher values.
//           Changed backwind SMS criteria from 0 to -0.1
//      2010-03-02 Version 3.11 (37,942 bytes)
//           Added MAX_TIDE_D! for maximum change in depth allowed between casts, and reworked the pertinent secitoin of GetDepth.
//           Changed default depth_target_cast from 0 to 2.5 to fix bug where cast target was 0 when no pinger values are returned.
//           Cleaned up CheckSMS by changing FOR lops to REPEAT loops.
//           Removed PINGER_DEPTH_M as the value is small and unchanging. This can be built in to the DEPTH_MARGIN_M value
//      2010-03-01 Version 3.10 (37,879 bytes)
//           Uncommented some errors in ErrorCheck.
//           Cleaned up comments.
//           Filtering labels in data headers was backwards.
//           Changed ZeroSondeDepth to CheckSondeCalibration and moved code to check depth and conductivity into this subroutine.
//      2010-02-26 Version 3.09 (37,376 bytes)
//           Fixed problem with wind files introduced in 3.08
//      2010-02-25 Version 3.08
//           Restored serial number to data file headers. ID wasn't enough.
//           Added SONDE_FILTERING flag in SETUP3.INI to turn on or off sonde filtering.
//           Changed DELTA_ERROR from 35 to 25 (percent) for fewer bottom strike errors near end of spool.
//           Added cast header line based on SONDE_FILTERING
//           Added cast header line for voltage
//           No SMS on bottom strike. Only on backwind.
//      2010-02-23 Version 3.07
//           Removed serial number from data file headers. ID should be enough.
//           Added depth_target_cast to record depth target of previous cast. Usefull when we can't get a water depth value.
//      2010-02-19 Version 3.06
//           Moved Messages in MotorRun before MotorOff calls (except in high current situations) so that log would make more sense.
//              This might slightly delay motor turning off in some cases.
//           RETURN out of MotorRun as soon as motor is turned off. Don't perform checks (which often fail) on stopped motor.
//           removed trailing M from some variables since all variables are assumed to be in meters.
//           Had to store clicks_counted to temp_INT in delta section of MotorRun to prevent it from changing mid-loop.
//           More changes to console to try to avoid modem echo feedback loop and logging unnecessary messages.
//           Made changes to waterline depths using SONDE_WL_MIN and SONDE_WL_MAX instead of hard coded values.
//           Added park command to console.
//           Added IsSondeRunning subroutine, used by StartSondeSampling
//           Increased DEPTH_BUFFER from 512 to 1024 and turned on pinger earlier to speed up GetDepth.
//           Added SMS message for backwind or bottom strike.
//           Changed AppendMessage so that 20 spaces are always prepended to make it line up with LogMessage. Added BasicMessage subroutine without the spaces.
//           ISCOmessage now passes message to LogMessage after recording it to ISCO_LOG_FILE
//           Simplified some print and log strings to clarify and save program space
//           Added cast_mode to OpenPort
//           Added section to MotorWatcher for state error with no current for external relay.
//           Changed sonde calibration deadband from .004 to SONDE_D_DB!
//           Re-wrote pressure sensor calibration logic
//           Cast clicks based on actual start depth rather than surface.
//           SetDateFromSonde checks to see if sonde is running
//      2010-02-16 Version 3.05 (never fully functional)
//           During the Docking section of the main loop don't use high current flag as a criteria for further raising.
//           Stores console commands to log file.
//           Pre-cast calibration is based on conductivity. Depth no longer considered. This is to correct for
//              large erroneous depth readings while out of the water.
//           Initial ReHome check during cast now REQUIRES conductivity be high. I.e. we trust conductivity much more than pressure.
//           Simplified messages in MotorRun.
//           Fixed typo so back-wind detection should now work.
//           Removed reHome code between Retrieve and Docking procedures.
//           Moved Retrieve and Docking procedures to ParkSonde subroutine
//           Fixed offset problem for parsing conductivity.
//           changed ENCODER_CYCLES_MAX from 600 (about 8" of travel) to 300.
//           Turn off echo and flush keyboard at the end of each cast.
//           If we are in Console mode, don't echo Logged Messages to the screen with OTEXT.
//      2010-01-29 Version 3.04 (38,328 bytes)
//           Added saltwater_cond to ini.
//      2010-01-23 Version 3.03
//           Changed working_depth_m to water_depth_m to make intent more clear.
//           Fixed some calculations for how depth_target is calculated.
//           Changed saltwater_cond from 2.0 to .4 and added *5 multiplier when raising.
//      2010-01-13 Version 3.02
//           Moved setting of sonde ID from SetDateFromSonde out to InitializeSonde
//           Removed /n from beginning of strings sent to sonde.
//           Changed argument on flttimec sonde command from 1 to 0 when not casting.
//           Added fltthresh and flton commands to flttimec as commands run when sonde sampling is
//              turned on or off. This is to improve depth sensor performance.
//           Added check_cond = 1 to section of code which lowers sonde from home to waterline.
//              This should prevent casts that start too high. Also changed this in ISCOCast.
//           Fixed delta clicks functionality (bad math) so we should now be able to stop backspooling.
//      2009-12-17 Version 3.01
//           Moved sonde_logging = 'F' to start of cast.
//           Added ABS to check for valid depth.
//      2009-11-19 Version 3.01
//           Made StartSondeSampling more fault tolerant
//           Added section to MotorRun. Every DELTA_CLICKS clicks (about 4 seconds) during MotorRun check depth delta.
//              if is is too small or negative, stop motor.
//           Changed current_idle from a correction factor to an actual current. Shouldn't make any difference.
//      2009-11-18 Version 3.00 (38,080 bytes)
//           Reads in SETUP3.INI instead of setup.ini
//           Changed almost all variables in cm to meters
//              Changed MAX_CAST_DEPTH_CM to MAX_CAST_DEPTH_M! (SETUP3.INI)
//              Changed max_depth_cm to max_depth_m! (SETUP3.INI)
//              Changed MIN_DEPTH_CM to MIN_DEPTH_M! (SETUP3.INI)
//              Changed CLICKS_PER_CM! to CLICKS_PER_M  (decimal) (SETUP3.INI)
//              Changed working_depth_cm! to water_depth_m! (SETUP3.INI)
//              Changed PINGER_DEPTH_CM to PINGER_DEPTH_M! (SETUP3.INI)
//              Changed DEPTH_MARGIN_CM to DEPTH_MARGIN_M! (SETUP3.INI)
//              Changed depth_targetCM! to depth_target!
//              Changed SONDE_OFFSET_CM to SONDE_CAGE_LEN!
//              Changed REHOME_DEPTH to REHOME_DEPTH!
//           Replaced main cast loop with call to MotorRun. This was the last loop to be converted.
//           Removed bump function in ReHome which was never used.
//      2009-11-18 Version 2.33
//           Removed "ping" console command and keep_pinger_running variable to save program space. Should re-load avp_help.txt
//           Changed OR to AND in two lines: ISCO_bottle >= 1 | ISCO_bottle <= ISCO_MAX_BOTTLES
//           For some reason, historically the ResetWatchDogTimer has set pin 2 high, then set it as
//              an input. In an earlier version, a PCLR 2 was added, but the PIN(2) remained. It has
//              been noticed that there are sometimes crashed to Tom8 here so PIN(2) has been removed.
//           If voltage_load is below LOW_VOLTAGE (SETUP3.INI) when the motor is stopped generate an error message.
//              If is happens on the day's last cast, generate SMS
//           Changed sonde re-calibration threshold from .002 to .004
//           Added HPSleep(600) after sonde calibration.
//           Added voltage_load! to record voltage while motor is running. Added to console - status
//           GetDepth now better calculates working_depth_cm when depth is deeper than cable allows.
//           If attempts to start sonde sampling fail, cast will be aborted.
//           Use a counter fail_count rather than temp_INT for StartSondeSampling timeout
//           Changed temp_volts to voltage_idle
//           Added a VSTORE/VGET(5) flag to indicate if previous exit was due to a crash. If so, we force program to re-load from EEPROM.
//           ctrl-x after ctrl-c resets cast_status to 0, which _might_ prevent an immediate re-cast.
//           While waiting to synchronize the cast, we can be up to 5 minutes late rather than the previous 2
//      2009-09-24 Version 2.32
//           Fixed a problem in sub console where a character entered sometimes resulted in a backspace. Did this by
//              adding key_pressed variable to replace temp_int.
//           Changed all sonde commands from menu driven to command line.
//           Added functionality to set many sonde parameters.
//           Checks report for correctness and warn if it is not formatted as expected.
//           ctrl-c twice exits quickly, ctrl-x exits SMS routine. No longer report sonde voltage.
//      2009-08-09 Version 2.31 (37,525 bytes)
//           Fixed a problem in ISCOrun where the program would get in an infinite loop at the last bottle.
//           Changed some PRINTs to STOREs in readsetupini
//           If the ISCO is enabled in ReadSetupIni, the subroutine calls ISCOscheduleRead (CRASH FIX)\
//           When status command is entered at console, results are stored to log file.
//      2009-07-22 Version 2.30
//           Move console help to avp_help.txt to reduce file size
//           Force retrieval to be negative ABS(x) * -1
//      2009-07-06 Version 2.29 (38,704 bytes)
//           Needed to reduce program size by 3K, commented out:
//              Most deBug=2 lines.
//              Most of ErrorCheck subroutine.
//           Fixed invalid comparison in GetDataStr which was ignoring every other line while motor was moving.
//           Light tweaks to GetSondeDepth
//           Changes to WaterlineDock to make it work better.
//           Created OpenPort Subroutine
//      2009-06-30 Version 2.28 (42,933 bytes. TOO BIG)
//           Added MAX_CAST_DEPTH_CM to prevent back-winding. This value should be added to SETUP3.INI
//      2009-06-01 Version 2.27
//           Fixed error in ISCOcast which stopped cast before waterline.
//           Added depth_targetCM to MotorDown message
//           Added more calls to ResetWatchDogTimer
//           If console is entered before 1st cast, no cast will occur until exit command, or console times out.
//      2009-05-26 Version 2.26
//           Added some deBug=2 lines to see why sonde depths are updating slowly
//           Console and subconsole don't check if it's time to cast before first cast.
//           Changes to partial file transfer command line.
//           Increased DEPTH_TIMEOUT from 7 sec (6600000) to around 12 (1400000).
//      2009-05-20 Version 2.25
//           Disable watchdog during file transfers.
//           Moved cast_status = 0 to end of main loop. Added watchdog reset to end of cast section of main loop before re-home check.
//           Cleaned up CheckSMS a little because program went to Tom8 here at least once.
//           Added The_Main_Loop for exit from Stoppage.
//           Commented out all lines with XMIT+ or XMIT - in them as this may be contributing to crashes?
//           Improved CastCheck so that there is a LOOP_STARTUP_TIME (+1) minute window in which a
//              cast will start rather than a 1 minute window.
//           Added ONERR ErrorCheck and ErrorCheck Subroutine.
//      2009-04-30 Version 2.24
//           Motor was not retrieving do to sign errors in MotorRun.
//           GetDepth now rejects depth values which are obviously too deep or too shallow. Added
//           SMS for working depths < MIN_DEPTH_CM
//           Check time before using SDATE.
//      2009-04-29 Version 2.23
//           Put more checks in for missing ISCO_FILE$.
//           Fixed timeout in NMEA depth routine.
//           Fixed error in xs|ys console command caused by implementation of partial downloads.
//           Altered MotorOff message to show depth target.
//      2009-04-24 Version 2.22
//           If there is no ISCO schedule, a manual cast will create one, appending every manual cast to the schedule.
//           After entering ctrl-x to escape from Stoppage, we are now returned to console.
//           Changed values of motor_running from ('T','F') to ('U','D','F') to keep track of direction.
//           MotorRun now better supports actions in both directions
//           Changed initial motor lower to use MotorRun
//           Changed main cast loop from REPEAT to WHILE loop
//           Changed boost_current scheme slightly.
//           Changed over_current_alm! to max_current_load!
//           Re-arranged and simplified items in MotorWatcher to speed things up.
//           Simplified ISCOcast. We may be able to take a deep sample followed by a shallow sample.
//      2009-03-26 Version 2.21
//           Changed all click_count to clicks_counted to use COUNT functionality. This leads to much greater accuracy.
//      2009-03-25 Version 2.20b Changes for ISCO. REQUIRES changes to SETUP3.INI
//           Fixed skip code in Console.
//           Added GetCFerrorCodes subroutine to print out better file error codes.
//           Fixed NMEA depth parsing.
//           Added sonde_chlor to display chlorophyll when manipulating motor.
//           Now use: COUNT clicks_counted with TPUCountChan to keep track of clicks.
//           Fixed all variable syntax to most_variables and MOST_CONSTANTS.
//           Added ISCOscheduleRead to read in ISCO schedule from ISCO_FILE$
//           Added ISCOcheck to see if it is time to perform an ISCO cast
//           Added ISCOcast to perform cast
//           Added ISCOrun set ISCO pin high and wait for sampling to finish.
//           Added ISCOmessage to log to ISCO_LOG_FILE$
//           Added abort feature to Stoppage
// NOTE      Implemented partial xmodem file transfers
//      2009-02-06 Version 2.13
//           Added boost option to up and down console commands.
//           Wait for modem to be ready before sending SMS message. Use CheckSMS subroutine for reboot message.
//           The CheckSMS routine now actively looks for modem response instead of just a long sleep.
//           changed smsAddress to SMS_ADDRESS (setup.ini)
//           Added more printed information to Stoppage.
//           Got rid of mdate option in console and corresponding ManualDate routine (holdover, never used).
//           After stopping at WL on a retrieval, we now check conditions to see if that last pull up is needed.
//           Added code to MotorRun which if it works will allow us to use MotorRun subroutine for main cast.
//      2009-01-27 Version 2.12 REQUIRES changes in setup.ini
//           Changed SONDE_DOCK_MIN from .5 meters to .3 meters to help at AVP0
//           Changed homeToWLmaxCM in CM to HOME_TO_WL_COUNT in clicks (setup.ini)/ Got rid of launchCount
//           Added WL_TO_HOME_COUNT settable in setup.ini for clicks from waterline up to home position
//           Added check_WLand check_cond flags to see if we are checking for the waterline or lack of conductivity during a MotorRun.
//              This should let us use the MotorRun routine everywhere we run the motor. There is a
//              slight concern that this may slow things down too much.
//           Added a few seconds of HPSleep in MotorWatcher if we get a ENCODER_CYCLES_MAX exceeded.
//              This is to allow the PTC to cool down.
//      2009-01-23 Version 2.11
//           Made number of re-homes at beginning of cast a settable ini value (REHOME_TRIES). Only
//              boost current on first re-home. Added REHOME_DEPTH as a variable.
//           Changed Console code to address possible modem feedback loops. Added command_str_MAX
//           to limit size of console message. Added a SLEEP and a KbFlush as well.
//           Changed CONSOLE_TIMEOUT sonde console timeout code. This wasn't a problem, but was
//              supposed to be n sec and was actually n/2.
//           Moved reboot SMS message up in program so we might be more likely to get it after a crash.
//           Added GetDate subroutine and now store today's date in EEPROM at address 0
//           Added PROFILER_NUMBER and stored it in EEPROM at address 1
//      2008-12-25 Version 2.10 (Skipped 2.08 & 2.09)
//           Altered GetDepth subroutine. Added support for NMEA depth and removed support for Datasonics pinger.
//      2008-10-23 Version 2.07
//           Fixed depth check in GetSondeDepth where values which are too large are rejected.
//           Better message after file transfer command.
//           Moved StopWatchStart() in GetDepth so that in Datasonics section it is only called when
//              a valid depth is received. It was being called anytime data showed up on port, but
//              this led to loop hang ups when there was gibberish.
//      2008-10-10 Version 2.06
//           Added clicks_desired information to MotorUp and MotorDown.
//           Changed SONDE_DOCK_MAX_CM & SONDE_DOCK_MIN_CM to SONDE_DOCK_MAX! and SONDE_DOCK_MIN!
//      2008-10-08 Version 2.05
//           Set wind frequency to 2Hz in InitializeWind. Somehow this was changing to 15Hz which caused hangups and reboots.
//           Added WIND_SAMPLE_MAX to escape from wind loop once enough samples have been taken.
//           Changed DEPTH_TIMEOUT to DEPTH_SYNC and added new DEPTH_TIMEOUT as loop escape.
//           Changed DEPTH_SAMPLES to DEPTH_SAMPLES_MAX
//           Added DEPTH_SAMPLES_MIN to replace hard coded value as the minimum number of pings required to re-calculate working_depth_cm
//           Added DEPTH_PERCENTILE! to replace hard coded value designating percentile of depth samples to use
//           Added keep_pinger_running to console to prevent pinger from turning off in PingerOff for x casts
//           Set wind frequency to 2Hz in InitializeWind. Somehow this was changing to 15Hz which caused hangups and reboots.
//      2008-10-07 Version 2.04
//           Fixed click count message after waterline retrieval.
//           Using MotorRun for console motor command.
//           Using MotorRun in ReHome twice.
//           Using MotorRun for final cast retrieval.
//           Might still use MotorRun elsewhere with modification.
//           Added watchdog reset to MotorOff and removed it from several places.
//           Fixed math error in ReHome introduced in 2.03 which didn't allow "bump"
//      2008-10-06 Version 2.03
//           Added SONDE_DOCK_MAX_CM and SONDE_DOCK_MIN_CM to define depth window where ReHome should initially
//             raise the sonde slightly rather than lower.
//           Added high_current boolean to indicate that motor was turned off due to high current.
//           Raised default REHOME_FREQ from 5 to every 10 casts. Probably could be 1000.
//           Changed naming convention for constants. Variables which are constants are now CAPITALIZED and no longer camel case.
//           Put in MotorRun subroutine, but not using it anywhere.
//           Added "done" message after xs or ys command to see in log when files finished sending.
//      2008-09-26 Version 2.02 Integrated Tony's changes into a generalized version.
//           Added AVP_SENSOR_CONFIG as index to sensor package with versions 1 and 2 for old (Neuse) and New.
//           Added AVP_SENSOR_CONFIG to ini file and removed DATA_OFFSET_DEPTH.
//           Used AVP_SENSOR_CONFIG to handle menu variations in ZeroSondeDepth
//           Added DATA_OFFSET_COND to handle variations in GetSondeDepth
//           Added DATA_REPLY_LEN for use in LogSondeData
//           Variables DATA_OFFSET_DEPTH, DATA_OFFSET_COND, and DATA_REPLY_LEN set in ReadSetupIni based on value of AVP_SENSOR_CONFIG
//           Added information regarding hardware to message in GetDepth
//           Found omission in Datasonics section of GetDepth where depths weren't being added to depth array.
//           Ports initialized after ReadSetupIni
//           Changed TPUUgetChan from (12) to (15)
//      2008-09-18 Version 2.01 Bug fixes (Tony)
//           Added line to correct voltage values in INIT message
//           Changed length constant in LogSondeData from 74 to 68
//           Changed offset for conductivity from 13 to 22 in getSondeDepth
//           Changed menu selection from 2 to 3 in ZeroSondeDepth for old sondes with old DO probes
//           THESE ARE SPECIFIC TO THESE SONDES AND THE WAY THEY ARE SET UP - NEEDS TO BE GENERALIZED
//      2008-09-02 Version 2.00 Version to support AVP0 with datasonics pinger
//           Added code in GetDepth to support Datasonics. Added message to InitializeDepth.
//           Added HOME_POSITION variable to ReadSetupIni.
//           Removed all code relating to maxMotorAmps. This code was commented out in version 1.47.
//      2008-08-28 Version 1.56
//           Changed message in GetDepth to show change in depth setting.
//      2008-08-28 Version 1.55
//           Added check in GetSondeDepth where new sonde_depth values are rejected if they exceed max_depth_cm!
//           Added temp_clicks = 0 before lowering to waterline.
//      2008-08-20 Version 1.54
//           Added some HPSleeps to StartSondeSampling. Sometimes we weren't starting the logging process. Only set sample rate on first cast.
//      2008-08-19 Version 1.53
//           GetDepth now checks for abnormally large reductions in Working Depth. These are usually
//              due to Pycnoclines. If a large depth reduction is detected, the previous depth reading - 10cm is used.
//      2008-08-15 Version 1.52
//           Sets sample rate to 1 sec in StartSondeSampling to fix YSI bug where hand held data logger always sets sample rate to 0.5.
//      2008-08-14 Version 1.51
//           No re-home is performed if a skip command is issued in boot console.
//           Some wording changes on GetDepth errors.
//      2008-08-13 Version 1.50
//           Three attempts will be made to set date from sonde.
//           Changed console command to manually change date from "date" to "mdate"
//      2008-08-07 Version 1.49
//           Two changes to GetDepth... Pinger results are only accepted if pings_good is at least .75 * DEPTH_SAMPLES_MAX
//           Instead of using median of pings, we now use 90th percentile.
//      2008-08-06 Version 1.48
//           Removed MotorWatcher call from GetDataStr subroutine to speed things up
//           Created LaunchCheck Subroutine and made position where clicks are checked a variable. Hopefully there is a small speed gain.
//      2008-08-04 Version 1.47
//           Re-calculate file names after waiting for SYNC_TIME. This will avoid having the data logged to the 32nd day.
//           Commented out all code relating to maxMotorAmps to speed things up.
//           Moved motor current check a little earlier in the MotorWatcher routine.
//           rearranged MotorWatcher calls in main casting loop to perhaps speed things up.
//      2008-08-01 Version 1.46
//           Narrowed failsafe check in main loop. Was 30-35 clicks, changed to 30. This could have been slowing things down and allowing a buffer overrun.
//           Altered data_reply message added in 1.44
//           Increased SONDE_IN_BUFFER from 1024 to 2048.
//      2008-07-30 Version 1.45
//           Changed messaging MotorWatcher when ENCODER_CYCLES_MAX is exceeded.
//      2008-07-30 Version 1.44
//           When sonde reaches top after cast, increased wait for depth/conductivity check from 2 to 10 seconds to give conductivity probe a chance to dry out.
//           Added error message in GetDataStr for DATA_BUFFER overrun.
//           Added check of data_reply length in LogSondeData. If data_reply is too long, it is truncated.
//      2008-07-29 Version 1.43
//           Increased ENCODER_CYCLES_MAX to 600
//      2008-07-22 Version 1.42
//           Added pings_bad to use when pinger is mis-behaving.
//           Store the wind date and time at the beginning of the cast so that it matches the cast. Set the cast and wind times' seconds to ":00"
//      2008-07-16 Version 1.41
//           Added software version to cast init string in message log.
//           If ENCODER_CYCLES_MAX is exceeded, motor shuts off. This may cause problems in other areas.
//           Added skip command to console to skip first cast.
//      2008-06-25 Version 1.4
//           Added support for PH reporting with DATA_OFFSET_DEPTH.
//           Added provision to increase max_depth_cm if we see a abnormal tidal surge.
//      2008-06-23 Version 1.3
//           Added checks so LEN() of string variables < 256. This is an effort to prevent crashes after ctrl-c.
//           Changes to Console routine. Added ctrl-x functionality. Added CONSOLE_TIMEOUT, tweaked response to "CONNECT"
//           Added support for comment lines in setup.ini
//      2008-06-20 Version 1.3
//           Big changes to scheduling system:
//              Changed SYNC_TIME to an array and added CastCheck routine. This should allow stored data to exactly synchronize with schedule
//           Update todays_date in console mode for writing to log file.
//           Console now ignores leading CRs. In order to get the command: prompt, send the string "hello"
//           Added line to move data and logs from midnight cast in to next day.
//      2008-06-20 Version 1.2
//           Changed temporary data_sleep_time from 0 to 1ms to avoid printing out *'s
//           Added 2 sec sleep at end of cast just after turning motor off. This should allow for a little more data to be collected.
//           Added check for sonde_logging in GetDataString so that a single line is returned if the motor is running --> OR we are logging <--
//           Instead of disabling watchdog during file transfers, watchdog is reset just before and
//              after transfer. If transfer takes longer than 20 minutes, system will be rebooted.
//      2008-06-18
//           Need to make sure that the lowering to waterline NEVER ends too early. Use distance and convert to clicks.
//           Added homeToWLmaxCM. This ensures that launchCount is never too low
//           After retrieval, added conductivity to pressure check which re-homes if we are still in the water.
//           Lowered threshold for retrieval waterline slow down from 10.9 cm to 5.9 cm.
//           When establishing sonde communications, timeout changed from 10 to 20 seconds. Should only take 7.5 seconds.
//           Added conductivity check to StartSondeSampling routine to be absolutely certain we are communicating with sonde.
//           Added several values to setup.ini. Marked all variables loaded with (SETUP3.INI) in comments
//           Extract conductivity if motor if we aren't logging -->OR motor is stopped.<-- and report it at end of cast.
//           Added temp_clicks to BOOST_COUNT check
//           Added TSerByteAvail() check to DataSend in an attempt to prevent occasional startup crashes.
//      2008-06-17
//           Added SONDE_ID to Initiating Cast message
//           Changed character that denoted the end of a sonde data line from \r to \n
//           Weakened failsafe check during cast so depth after 30 clicks only has to be > than SONDE_WL_MIN
//      2008-06-16   Changed version to 1.1
//           Added debugging to ReadSetupIni to track down issues loading from setup.ini
//           Changed message when conductivity or depth is unexpectedly high from "jam" to "not fully retrieved"
//           Added check for conductivity to "Retrieve:" section. This should help with docking in rougher conditions.
//           Removed DEPTH_MARGIN_CM/2 from calculation of clicks_desired for main cast. This was in there as a safety, but should not be needed.
//           Added support for ymodem which should remove extra characters at the end of downloaded files.
//      2008-06-12&13   Deployment Version 1.0 PLATFORMS DEPLOYED IN FIELD
//           Changed HOME_POSITION to 2 need to add this to setup.ini (DONE)
//      2008-06-11   Office Testing
//           Added: DEPTH_MARGIN_CM, working_depth_cm, MIN_DEPTH_CM, max_depth_cm to setup.ini
//           Added list of pinger depths to log file (was deBug=2)
//      2008-06-06   Office Testing
//           Added: "- sonde_depth/100" to clicks_desired calculation before main cast. This code no longer assumes start is at waterline.
//      2008-06-05   Office Testing
//           File names are generated from date at the beginning of a cast only. This avoids having a cast's messages split if the cast occurs around midnight.
//           Added comments and changed a few variable names including tempDec -> temp_INT and tempDate --> todays_date
//           Added more checks of conductivity where appropriate.
//           Added error message if we calibrate sonde from a large negative number to 0, this indicates that there was an erroneous calibration previously
//      2008-06-03   Office Testing
//           Added ReadSetupIni routine which gives ability to read certain variables out of the setup.ini file on the CF card.
//      2008-05-30   In water testing
//           Tweaked behavior when we dial in.
//           Used sonde_conduct to error check various procedures including re-calibration and current boosting
//           A little better checking of picoDOS strings
//      2008-05-29   In water testing
//           Added cast_mode$ to simplify prepending log messages.
//           Code to slow sonde at waterline during re-home led to mangled funnel and blown fuse so...
//           Re-wrote code to slow sonde at waterline.
//           Created WaterLineDock routine for use during cast retrieval and Re-Home to slow sonde as it approaches the waterline
//           Tweaked how current is boosted and un-boosted. Implemented temp_clicks to save click_count through WaterLineDock and other procedures
//           Added sonde conductivity (sonde_conduct!) to be used as another measure of our location with regards to the waterline.
//      2008-05-28   In water testing
//           Added "status" and removed "volts" from console
//           Console will ignore its own error messages if echoed by modem.
//           Turned on sonde sampling before initial re-home so that AMPS_LOW functionality will work.
//           Altered boost functionality, so it is only in effect for a certain number of clicks. This is to avoid jamming at the top.
//           Changed messaging when maximum click states are exceeded. It now reports when motor is turned off, rather than when exceedence occurs.
//           Changed code to bypass setting date from sonde if communications can not be established.
//      2008-05-27   In water testing
//           Minor message and formatting changes.
//           Fixed condition where watch dog timer was never reset from console mode.
//           Fixed condition where program would hang if no depth data was being received
//           Added sonde depth retrieval to ReHome routine
//      2008-05-23   In water testing
//           Fixed (finally) wind calculations. Increased windBuffer from 4K to 16k
//           Added AMPS_BOOSTED functionality to clear jams
//           Made operation less dependant on clicks if we have a failure
//      2008-05-22   In water testing
//           Added re-home if initial sonde depth is >= 30 cm or sondeDepth at end of retrieval is > 10cm
//           Tweaked messages some more, added RING and CONNECT to console words (to ignore).
//           Increased wind in priority to 2, same as sonde. Increased buffer
//           Checks progress on cast after 50 clicks. If sondedepth has not reached 10cm, retry then abort
//      2008-05-21   In water testing
//           Tweaked messages and deBug printing.
//           Added depth and rehome commands to console
//      2008-05-13   In water testing
//           Use debug flag to speed things ups
//           SMS implementation (NOT USED)
//           Making sure that program can not get hung up in any loops due to component failure
//           Made baud rate a variable and upped it to 19,200. Also speed up SimSetFSys a little for better accuracy.
//      2008-05-12   In Water Testing
//           Minor corrections and message formatting
//           Returning to a good place after cast, files look good
//      2008-05-08
//           Wind calculations corrected
//           Merged WindConsole and SondeConsole routines to SubConsole
//           Merged SondeSend and WindSend routines to DataSend
//           Merged GetSondeStr and GetWindStr routines to GetDataStr
//           Changed LogMessage system to use STORE command for better message formating
//           Doesn't calibrate sonde if it is in the water.
//           Cleaned up sonde send
//      2008-05-07   In Water Testing
//           Fixed garbage in data file. Removed many PRINT statements. Working fairly well.
//           Doesn't calibrate if sonde is still in water at beginning of first cast.
//      2008-05-06   In Water Testing
//           Fixed issue with over-current before first click
//           Fixed units on depth_targetCM and sonde_depth.
//           Seem to have solved all parsing problems
//           Sometimes motor current > 4.2 amps on retrieval after cast
//      2008-05-02   In Water Testing
//           Tweaked wind code to parse from end of string rather than beginning.
//           Moved ReHome to a subroutine
//           Added sonde_depth check to retrieval loop
//           Tweaked code during launch to speed things up
//      2008-05-01   In Water Testing
//           Can no longer get stuck in Console when it's time to cast
//           Lowered port priority for sonde
//           Fiddled with side of strings passed to GetDepth
//           Still missing clicks during casts
//           Added wind console but didn't implement it
//      2008-04-30   In water testing
//           Removed wind collection during cast
//           Removed depth rate change monitoring (tangle)
//      2008-04-23
//           Moved Reset of encoder_cycles to MotorUp and MotorDown
//           Added console functionality & clean up
//
//------------------------------------------------------------------

//------------------------------------------------------------------
//     Digital IO Ports
//    PIN: PR-8: Function
//      0:   17: Motor rotary encoder
//      1:   16: ISCO trigger (AVP0)
//      2:   15: Watchdog Reset
//      3:   14: Pinger (depth sounder) switched ground
//      4:   13: Encoder switched ground.
//      5:   12: Motor Down
//      6:   11: Motor Up
//      7:   10:
//      8:   09: Seatalk Input Port (AVP1,AVP2)
//      9:   08: RS232 Tx - Wind out port
//     10:   07: RS232 Rx - Wind in port
//     11:   06: RS232 Tx (altim transmit) but not used
//     12:   05: RS232 Rx used as NMEA input port on AVP0 unused on AVP1 & 2
//     13:
//     14:
//     15:   20: Used as a dummy channel for TPUUgetChan()
//     16:   ??: Used as a dummy channel for TPUUsendChan()
//    Analog Inputs:
//      6:  101: Input voltage
//      7:  100: Motor Amps
//
// EEPROM memory allocations (VGET(n),VSTORE n,)
// 0 - today's date (CCYYMMDD)
// 1 - platform number (currently 0-2)
// 2 - ISCO bottle number (0,1 to ISCO_MAX_BOTTLES) outside this range means either done or not enabled
// 3 - Previous Day's end of day cast_count.
// 4 - Overall cast number. This is incremented only once daily, so if AVP is
//     restarted during the day, this value may be inaccurate.
// 5 - Crash Status. 0 = last exit was due to a crash
//                   1 = exit due to crash recovery
//                   2 = exit due to Ctrl-C
//------------------------------------------------------------------
ENDIF
//----------------------------------------------------------------------------\
//        GLOBAL VARIABLES                                                    |
//   These variables should not need adjusting                                |
//   Variables with SETUP3.INI in comment may be set in setup file.           |
//   Variables in all capitals are constants.                                 |
//   Constants may be altered by contents of SETUP3.INI                       |
//----------------------------------------------------------------------------/
PROFILER_LOCATION$ = "Testing"     // Location of the platform (SETUP3.INI)
PROFILER_NUMBER = VGET(1)                      // Which platform is this (0-2)
// Scheduling
//    To run the winch only twice per hour, simply set SYNC_TIME(0) = 0 and
//       SYNC_TIME(1) = 30. Set SYNC_TIME(x) value to 99 to ignore
//       At least six minutes should be alloted per cast
DIM SYNC_TIME(6)        // Array to hold  six cast times
                        // The SYNC_TIME values should be between 0 and 59 in SETUP3.INI
LOOP_STARTUP_TIME =  3  // Minutes before SYNC_TIME(0-5) that cast loop should start (SETUP3.INI)
                        //    Once initial procedures are done, program will wait to synchronize with scheduled cast.
cast_status = 0         // Used to indicate it is time to cast and why
                        //   -2 = ISCO cast at current depth (Manual),
                        //   -1 = ISCO cast to scheduled depth,
                        //    0 = not time to cast, or abort cast
                        //    1 = cast with schedule sync
                        //    2 = Cast immediately without sync
AVP_LIMIT_RELAY = 0     // Set to 1 if the platform has a sensor and relay to prevent the motor from
                        // pulling up the sonde too far. (SETUP3.INI)

//   Messaging & Logging Variables
msg_pointer = 21      // The first 20 bytes of the Data File are used for the time stamp
                      // the rest of the message fits between 21 and 255
DATA_PTR_BEGIN = 500   // Start position in Data File of Sonde log data. 100 is too small
                      // The LogMessage routine uses memory starting at 0
data_file_ptr = DATA_PTR_BEGIN // Pointer to current memory location to log data. Starts at DATA_PTR_BEGIN
previous_pointer = 0    // Keeps track of pointer from previous STORE() to extract data
msg_begin = 1         // Points to the Data File location when the current message begins
MSG_STR_BEGIN = 21    // This is where the contents of the message (excluding timestamp) begin.
msg_log_file$ = "default.log" // File where messages are stored
sms_msg$ = ""         // Holds message to be sent via SMS. Can not contan CRs. Keep brief.
cast_mode$ = ""       // holds current cast mode for log labeling.
SMS_ADDRESS$ = "whipple@mail.unc.edu"  // Address to which critical alarm messages are sent (SETUP3.INI)

// Motor Variables
HOME_TO_WL_COUNT = 60   // Maximum number of clicks from
                        // fully up position to when pressure sensor hits
                        // waterline. (SETUP3.INI)
WL_TO_HOME_COUNT = 40   // Number of clicks to raise up from waterline to home (storage) position. (SETUP3.INI)
HOME_POSITION = 2       // Number of clicks down from the top to the home (storage)
                        // position. Should be 2 or more. (SETUP3.INI)
CLICKS_PER_M = 90       // Number of optical encoder states  (SETUP3.INI)
STARTUP_CLICKS = 5      // Number of clicks to drop before Re-home to prevent jam
AMPS_LOW! = 1.1         // Low current to use at end of home when sonde is out of water. (SETUP3.INI)
AMPS_NORMAL! = 1.35     // Standard current threshold (SETUP3.INI)
AMPS_BOOSTED! = 2.2     // Higher current threshold when jammed on retrieval (SETUP3.INI)
LAUNCH_CHECK_CLICKS = 30 // Number of clicks into cast where depth & conductivity
                         //    should be checked to see if we should abort. (SETUP3.INI)
BOOST_COUNT = 30        // Number of clicks to boost current for.
CURRENT_MULIPLIER! = 0.000110571  // This is multiplier on CHAN(7) which gives us amps.
PTC_CURRENT_MAX! = 0.3  // Maximum current the PTC will draw when tripped. (SETUP3.INI)
PTC_CURRENT_MIN! = 0.05 // Minimum current the PTC will draw when tripped. (SETUP3.INI)
current_idle! = CHAN(7) * CURRENT_MULIPLIER! // This is the motor amps draw at rest.
current_load! = CHAN(7) * CURRENT_MULIPLIER! - current_idle!     // Amount of current motor is drawing.
voltage_idle! = 12.0    // Used to hold voltage values when motor stopped.
voltage_load! = 12.0    // Used to hold most recent loaded voltage value.
LOW_VOLTAGE!  = 11.5    // Low voltage_load alarm level. (SETUP3.INI)
INRUSH_CLICKS = 2       // Number of clicks until current should be normal.
MOTOR_FUSE! = 6.0       // This amount of current will stop the motor at any time.
max_current_load! =  AMPS_NORMAL! // Over-current threshold in Amps. Above this and the motor will stop
boost_current = 'F'      // Flag to use AMPS_BOOSTED value. Set to 'F' once current is bosted.
motor_running = 'F'      // Flag when motor is running (F,U,D) False, Up, Down
high_current = 'F'       // Flag to indicate that motor was shut down due to a current error.
                         //    After a high current stop, remains = 'T' until motor is run again.
cast_count = 0           // Counts casts. Used for re-homing.
temp_clicks = 0          // Used to save click_count during start stop sequences.
clicks_counted = 0       // This will use the COUNT command to keep track of counts.
clicks_last_counted = 0  // Used to keep track when clicks_counted changes.
clicks_desired = 0       // Number of clicks desired until stop.
retrieve_count = 999     // Number of clicks to retrieve from bottom to surface.
depth_target! = 0.000    // This is target depth passed to the MotorRun subroutine.
depth_target_last! = 0.000 // THis is the depth target for the cast.
encoder_cycles  =  0     // Counts loop iterations between click state changes.
ENCODER_CYCLES_MAX = 300 // Maximum loop iterations with the state unchanged.
                         // If this number is exceeded an error condition exists.
                         // Most likely a failure of the photo-diode, motor, or winch. (hatch open too)
ENCODER_MAX_TIME = 2000000 // Maximum time beween clicks without generating an error SETUP3.INI
SONDE_DOCK_MAX! = 0.8  // Lower depth limit where jam might respond to a slight raise.
SONDE_DOCK_MIN! = 0.3  // Upper depth limit where jam might respond to a slight raise.
check_WL = 0           // When set to 1, the MotorRun routine checks or retrieval to see when the sonde approaches the waterline and slows it down.
check_cond = 0         // When set to 1, MotorRun will check for conductivity as a trigger to stop.

//   Sonde Variables
SONDE_ID$ = "?"        // Sonde ID. Will be set when sonde is initialized.
SONDE_SN$ = "?"        // Sonde Serial Number. Will be set when sonde is initialized.
SONDE_PARA$ = "?"      // Result of the para command. Tells us what sensors we have and in what order.
SONDE_IN_BUFFER = 2048 // Number of bytes in our serial input buffer.
SONDE_OUT_BUFFER = 256 // Number of bytes in the sonde's serial output buffer.
                       //    This number can be much smaller than the Input Buffer.
SONDE_OUT_PORT  = 13   // This is the secondary TX port.
SONDE_IN_PORT   = 14   // This is the secondary REC port.
SONDE_BAUD     = 9600  // Secondary serial port baud rate.
sonde_logging = 'F'    // Set to 'T' when we are logging sonde data.
sonde_running = 'U'    // Set to 'T' when we are getting data or 'U' when unknown
CONSOLE_TIMEOUT  =  20 // This is the timeout while on the regular and sonde console (will be in seconds).
sonde_depth! = 999.999 // This is the depth at which the sonde thinks it is. (in Meters)
sonde_depth_max! = 0.0 // Set to sonde_depth whenever sonde_depth exceeds value expected by DELTA values. Used for Backwind
sonde_samples = 0      // Tracks the number of samples per cast. Used for backwind.
SONDE_D_DB!  =   0.004 // This is the deadband in meters around 0 inside which the sonde is not recalibrated.
DELTA_CLICKS = 12      // Click Frequency to check depth change (SETUP3.INI) used for backwind
DELTA_ERROR = 25       // This is a percentage of expected depth change below which an error is flagged. Used for backwind
DELTA_D_MIN! = .01 * FLOAT(DELTA_ERROR) * (FLOAT(DELTA_CLICKS) / FLOAT(CLICKS_PER_M)) // DELTA_ERROR% of expected travel. Will be recalculated from SETUP3.INI values. Used for backwind
clicks_last_delta = 0  // Make sure we don't check the same click number twice. Used for Backwind
sonde_depth_last! = 0.000 // This will hold the value of sonde_depth taken DELTA_CLICKS previously.
                       // This is the minimum change in sonde_depth over DELTA_CLICKS which won't cause an error. Used for Backwind.
SONDE_WL_MIN! = 0.009  // The top end of a band of water depth considered to be the waterline
SONDE_WL_MAX! = 0.060   // The bottom end of a band of water depthc considered to be the waterline
sonde_conduct! = -9.999 // Sonde recorded conductivity  Unknown  = -9.999 error = -8.888
saltwater_cond! = 1.000 // A value of sonde_conduct > saltwater_cond indicates the conductivity probe is in salt water
                       // sonde_conduct < saltwater_cond indicates air or fresh water (initialized in SETUP3.INI)
sonde_chlor! = -99.9   // Sonde recorded Chlorophyl
SONDE_FILTERING = 1    // If set to 1, the sonde's filtering capabilities will be enabled. (SETUP3.INI)
DATA_OFFSET_DEPTH = 35 // The number of characters between the start of the depth data and the end of the line
                       // Will be altered in InitializeSonde based upon return of para command
DATA_OFFSET_COND = 13  // The number of characters between the start of the depth data and the start of the conductivity data
                       // Will be altered in InitializeSonde based upon return of para command
DATA_REPLY_LEN = 74    // The expected length of a data line
                       // Will be altered in InitializeSonde based upon return of para command
REHOME_DEPTH! = 0.100  // Depth at start up below which the sonde is consiered to be in the water and needs a re-home
                       // The sonde will not re-calibrate until it sees a depth less than this.

// Depth Sounder (pinger)
water_depth_m! = 4.300 // Median depth (in meters) as calculated by the sounder
                        // from an array of size DEPTH_SAMPLES_MAX. This values is
                        // used as an initial estimate. 4.30m ~ 14ft (SETUP3.INI)
MIN_DEPTH_M! = 1.500    // Minimum water depth (in m). Used to reject spuriously shallow readings. (SETUP3.INI)
max_depth_m! = 5.000    // Maximum water depth in m, used to reject spuriously deep readings. Prevents too much
                        // spooling of cable.(SETUP3.INI)
MAX_CAST_DEPTH_M! = 4.000 // This is the maximum depth the platform can cast to before the line starts
                        // backspooling. It will depend mostly on cable length. (SETUP3.INI)
DEPTH_MARGIN_M! = 0.400 // Distance (in m) to stop sonde before
                        // reaching depth value. (Distance off bottom at end
                        // of cast) This can be dependent on the type of bottom.  (SETUP3.INI)
MAX_TIDE_D! = 0.30      // If the difference between the current depth value and the previous one is greater than this, it is suspect.
DEPTH_PORT = 8          // Depth input Port, 8 for SeaTalk, 12 for NMEA 0138 (SETUP3.INI)
DEPTH_BAUD = 4800       // Depth input Baud, 4800 for NMEA and SeaTalk, 9600 for Datasonics (SETUP3.INI)
DEPTH_BUFFER = 1024     // Was 512.
DEPTH_SYNC = 100000     // Clock cycles to wait for good data from pinger for syncing
DEPTH_TIMEOUT = 1000000 * 6 // Timeout per sample (6 seconds)
DEPTH_SAMPLES_MAX = 60  // Number of pings collected to calculate water_depth_m! (Max based on array size)
DIM ping_array!(61)     // Array of Depth samples in meters used to find median
DEPTH_SAMPLES_MIN = DEPTH_SAMPLES_MAX * .75 //Minimum number of pings required to re-calculate water_depth_m
DEPTH_PERCENTILE! = 0.9 // Percentile of depth samples to use
pings_good    = 0           // Number of good pings in current attempt
pings_bad     = 0           // Number of bad pings in current attempt
temp_byte_count    = 0           // Counts bytes when parsing depth values

// Wind Variables
WIND_OUT_PORT = 9       // Serial output port for wind instruments.
WIND_IN_PORT = 10       // Serial input port for wind instruments.
WIND_IN_BUFFER = 1024 * 16     // Size of buffer on wind Serial port. Should be at least 16k
WIND_WORD_LEN = 41      // Length of a word of data from the wind instrument
WIND_SAMPLE_MAX = 1000  // Maximum number of samples required.
command_str$ = ""          // Holds a line from the wind sensor for parsing
wind_samples = 0         // Number of wind samples takes.
wind_velocity! = 0.0     // Wind velocity.
wind_north! = 0.0        // NS component of wind samples.
wind_east! = 0.0         // EW component of wind samples.
wind_compass! = 0.0      // Platform heading from wind instrument
wind_direction! = 000.0   // Average weighted wind direction
// ISCO Sampler variables
ISCO_ENABLED = 0         // Set to 1 by SETUP3.INI if there is an ISCO sampler attached and enabled (SETUP3.INI)
ISCO_SLEEP_TIME = 60 * 3 // Time to sleep in seconds while ISCO samples(SETUP3.INI)
ISCO_bottle = VGET(2)    // Current Bottle Number
ISCO_MAX_BOTTLES = 24    // This number MUST be <= the first ISCO_sched array size below
DIM ISCO_sched(30,3)     // There are 24 bottles and three values per bottle (date, time, depth in CM). All values are integers
ISCO_FILE$ = "isco_sch.txt"      // This is the ISCO schedule file
ISCO_LOG_FILE$ = "isco_log.txt"  // This is the ISCO log file


// Misc. Variables
command_str$ = ""        // Holds user input commands.
command_str_MAX = 100    // Maximum character length of command_str$
data_in_port = 0         // Holds the current Input Port value
data_out_port = 0        // Holds the current Ouput Port value
data_send_str$ = ""      // Holds string to send to the sonde.
data_file$ = ""          // Holds file name for various CF PicoDOS commands
data_reply$ = ""         // Holds sonde or wind reply to the sent string when GetDataStr is called.
DIM sub_arg(10)          // Used for Subroutine Arguments
data_reply_full = 'F'    // Set to 'T' by GetDataStr when data_reply variable is full.
                         // This indicates that there is more data available.
DATA_BUFFER = 80         // The number of characters required in the sonde or wind buffers
                         // before a call to GetDataStr is made. this is one VT100 line.
data_sleep_time = 200    // This is the amount of time to pause when doing non-console interaction with sonde.
temp_sleep_time = 0      // Used to temporarily hold previous values of data_sleep_time
todays_date = 20000101   // Holds today's date as an integer (CCYYMMDD)
fail_count = 0           // Counts bad data in GetDepth and StartSondeSampling
pointer_address = 0      // Used for converting integers to ASCII.
// PICO_COMMANDS$ is used to hold PicoDOS commands
PICO_COMMANDS$ = ".baud.boot.capture.ccc.copy.date.del.dump.dir.erase.format.g.help.lo.md.mm.opt.ren.reset.save.time.tom8.type.ver.xr.xs.ys.yr."
i = 0 : j = 0            // Used mostly for FOR NEXT loops

// The tempXXX variables are LOCAL and should be used VERY carefully when subroutines
//    are called as their contents may change if a subroutine is called!
temp_INT = 0              // Used LOCALy to temporarily hold an integer value
key_pressed = 0           // Used to hold the ascii value of the last key pressed.
temp_FLT! = 0.0           // Used LOCALy to temporarily hold a float value
temp_STR$ = ""            // Used LOCALy to temporarily hold a string

// Tattletale Model 8 Extensions. (Not all are used)
// The first three are PicoDOS Compact Flash extensions.
EXTENSION CFSave
EXTENSION CFRead
EXTENSION CFExec
EXTENSION ConvertVarPtr // Returns the address of the variable requested.
EXTENSION CtrlCHandle   // Enable or disable handling of Ctrl-C character.
EXTENSION CtrlCReset    // This clears the Ctrl-C detect count.
EXTENSION HPSleep : HPSleep(0)  // Primarily a delay mode where the model 8 stays in a
                        // running condition and the TPU serial ports can
                        // still gather characters.
EXTENSION KbChar        // Returns the next available character from the primary serial port.
EXTENSION KbFlush       // Removes any characters received by the primary serial port from its input queue.
EXTENSION KbHit         // Checks to see if a character has been received by the primary serial port (ie. a key pressed).
EXTENSION SerSetBaud    // Returns the actual baud rate set by the arguments passed to it.
EXTENSION SimSetFSys    // Sets the system clock as close as possible to the freq argument variable.
EXTENSION StopWatchStart // Starts the microsecond stopwatch counter and
                         // initializes it to zero for subsequent calls by StopWatchTime.
EXTENSION StopWatchTime  // Returns the current value in the microsecond stop watch counter.
EXTENSION TPUCountChan   // Changes the TPU pin used for the TxBASIC COUNT command to the pin chan.
EXTENSION TPUUgetChan    // Change the TPU pin used for the TxBASIC UGET command to the pin chan.
EXTENSION TPUUsendChan   // Change the TPU pin used for the TxBASIC USEND command to the pin chan.
EXTENSION TSerByteAvail  // Checks to see if any bytes are available in the buffer of the specified channel.
EXTENSION TSerClose      // Closes the TPU serial port specified as chan.
EXTENSION TSerGetByte    // Gets the next byte from the channel input queue or
                         // waits for the next byte if no bytes are available.
EXTENSION TSerInFlush    // Flushes the channels input queue and discards any characters in this queue.
EXTENSION TSerOpen       // Opens a TPU channel for serial I/O.
EXTENSION TSerPutByte    // Writes a byte of data to the channels output queue.

//-----------------------------------------------------------------------------
//                           Program startup sequence
//-----------------------------------------------------------------------------
SimSetFSys(15360000)    // Speed up the system clock.
SerSetBaud(9600)   // Set the comm port baud rate.
CBREAK Stoppage         // Upon break, go to subroutine 'Stoppage'
ONERR ErrorCheck, temp_INT        // Upon an error, go to subroutine 'ErrorCheck'
TPUUsendChan(11)        // We cannot open the Usend default channel (13) with TSerOpen,
                        //    so we reassign them to an unused channel.
TPUUgetChan(15)         // We cannot open the Uget default channel (14) with TSerOpen,
                        //    so we reassign them to an unused channel.
TPUCountChan(0)         // Changes the TPU pin used for the TxBASIC COUNT command to the pin 0
STORE msg_pointer, "Ver:",VERSION$,"  Mod:",FILE_MODIFIED : GOSUB BasicMessage
GOSUB GetDate
sms_msg$ = sms_msg$ + "Rebooted " // Send our reboot message
voltage_idle! = CHAN(6) : voltage_idle! = (CHAN(6)/4369.0) + 1.7 // Charge up a/d from voltage divider then record actual voltage
STORE msg_pointer, "Voltage:", #5.2F,voltage_idle!, " V." : GOSUB BasicMessage
GOSUB MotorOff           // Make sure motor is stopped
GOSUB ResetWatchDogTimer // Restart the watchdog timer
GOSUB ClearSched        // Set all SYNC_TIME() entries to 99.
GOSUB InitializeSonde    // Initialize the YSI sonde. (this also sets date, time, ID & SN
GOSUB ReadSetupIni       // Read SETUP3.INI if it exists and set values accordingly
GOSUB InitializeWind     // Initialize the wind systems
GOSUB InitializeDepth    // Initialize Depth Sounder (pinger)s (port depends on ini file)

// ------- Provide Access to console -------------
KbFlush()
FOR i = 10 to 1 STEP -1
    PRINT "\resc or ctrl-x for console (",i, ")   ";
    IFF KbHit()
        key_pressed = KbChar()// If there is a character from the keyboard
        IFF (key_pressed = 24 | key_pressed = 27)
            PRINT ""
            GOSUB Console
            i = 1  // Exit loop upon RETURN from Console
        ENDIF
    ENDIF
    HPSleep(0) : HPSleep(100)
NEXT i
PRINT "" // Get a new line

IF cast_count = 0 cast_status = 2 // If a skip command wasn't issued, cast right away
//-----------------------------------------------------------------------------\
//                                                                             |
//              The_Main_Loop BEGINS                                           |
//                                                                             |
//-----------------------------------------------------------------------------/
The_Main_Loop: // This gives us a way to re-enter the main loop if something goes wrong.
WHILE 1 // Could replace WHILE with GOTO The_Main_Loop
    // See if it's time to do a cast or were have just initialized or we want a manual cast
    GOSUB CheckSMS  // See if we have a message to send
    GOSUB CastCheck // returns cast_status upon which we base the decision to cast
    IF cast_status = -1 & ISCO_ENABLED GOSUB ISCOcast   // Time for an ISCO cast
    IFF cast_status > 0 // Time to cast
        GOSUB PingerOn              // Turn on sounder to give it time to start up
        GOSUB ResetWatchDogTimer    // Restart the watchdog timer
        GOSUB StartSondeSampling  // Put the sonde in sampling mode (takes a few seconds) returns when there is a word of sonde data
        GOSUB GetDate  // Get the date which will be used for all file names during this cast.
        voltage_idle! = CHAN(6) : voltage_idle! = (CHAN(6)/4369.0) + 1.7 // Charge up a/d from voltage divider then record actual voltage
        STORE msg_pointer, "INIT: ------- Cast Number ",cast_count + 1," on ",SONDE_ID," AVP",PROFILER_NUMBER,". ", #5.2F,voltage_idle!, " V, Ver: ",VERSION$," ----------"  : GOSUB LogMessage
        GOSUB EncoderOn           // Turn on the encoder for the duration of the cast
        TSerInFlush(WIND_IN_PORT) // Clear the wind port's buffer and start collecting data
        sonde_logging = 'F'  // NOT logging sonde data until we get in the water
        // The sonde should be parked up in it's tube at this point
        // Check if sonde is in the water when it should be in home position, if so, try to re-home.
        IFF sonde_depth! > REHOME_DEPTH! & sonde_conduct! > saltwater_cond! // changed | to &
            STORE msg_pointer, "ERROR: Not fully retrieved at cast start. Depth: ",#5.3F,sonde_depth!," > ",REHOME_DEPTH!,", Cond: ",#5.2F,sonde_conduct!,"." : GOSUB LogMessage
            boost_current = 'T'
            cast_mode$ = "INIT (Parking): "
            GOSUB ParkSonde // This used to be rehome
        ENDIF

        GOSUB CheckSondeCalibration   // Now see if we need to calibrate the pressure sensor
        GOSUB StartSondeSampling  // Need to put the sonde back in sampling mode if there was a calibration
        //GOSUB GetSondeDepth  // not needed
        IF sonde_depth! = -9.999 GOTO The_Main_Loop // We never got sonde communications so abort cast

        // LOWER SONDE to waterline (pressure sensor is submerged).
        // This should be evident by a change in sonde_depth and sonde_conduct
        temp_clicks = 0
        depth_target! = SONDE_WL_MIN! // Lower to waterline
        clicks_desired = HOME_TO_WL_COUNT
        cast_mode$ = "WL: " // used to prepend motor messages
        // check_WL = 0 // Only used on the way up (not needed after 3.15)
        check_cond = 1 // Added in version 3.02 to prevent early stops on bad data
        STORE msg_pointer, "",cast_mode$,"Lowering until (sonde depth > ",#5.3F, depth_target!, "m and cond > ",#3.1F,saltwater_cond,") or ",#3D, clicks_desired," clicks." : GOSUB LogMessage
        GOSUB MotorRun
        sonde_samples = 0 // Reset sample counter.
        GOSUB GetSondeDepth
        STORE msg_pointer, "",cast_mode$,"Initial Sonde Depth ",#6.3F,(sonde_depth!), "m. Conductivity:  ",#6.3F,sonde_conduct!, "mS/cm." : GOSUB AppendMessage
        STORE msg_pointer, "",cast_mode$,"Launch count was ",#3D,clicks_counted," of ", clicks_desired," clicks down from home position." : GOSUB AppendMessage
        STORE msg_pointer, "",cast_mode$,"Initiating ~60 sec Cleaning Cycle." : GOSUB LogMessage
        GOSUB SetDataSonde
        data_send_str$ = "\x1B"  : GOSUB DataSend     // Stop sampling by sending an ESCAPE
        data_send_str$ = "twipeb\r\n"  : GOSUB DataSend   // start the wiper

        // Check depth from sounder (pinger).-------------------------------------------------------
        // This takes time to get enough samples, but gives the wipers time to finish
        HPSleep(0) : GOSUB GetDepth // Returns water_depth_m! which should be the distance from the waterline to the bottom
        GOSUB PingerOff // No longer need it
        GOSUB StartSondeSampling    // Turn sampling back on
        IF sonde_depth! = -9.999 GOTO The_Main_Loop // We never got sonde communications so abort cast
        GOSUB GetWindData  // Collect all wind data on buffer so far

        // Wait for SYNC_TIME to start logging.-----------------------------------------------------
        // There is a 5 minute pad if the initialization took a long time
        WHILE cast_status <= 1 & cast_status <> 0 // Don't wait on first cast where cast_status = 2
            HPSleep(0)
            RTIME : temp_INT = ?(1)
            FOR i = 0 to 5  // There are six possible time slots in the array
                temp_INT = ?(1)
                IFF SYNC_TIME(i) < 60  // Anything over 60 is not valid
                    IF temp_INT <= 2 & SYNC_TIME(i) >= 58 temp_INT = temp_INT + 60 // takes care of times near the top of the hour
                    IF deBug PRINT "[sch# ",#2D,i,":",#3D,SYNC_TIME(i) - temp_INT," min to go] ";
                    IFF (SYNC_TIME(i) - temp_INT <= 0) & (SYNC_TIME(i) - temp_INT >= -5)  // We can be up to 5 minutes late.
                        cast_status = 2 // Cast right away
                        i = 999 // no more need to loop
                    ENDIF
                ENDIF
            NEXT i
            IF cast_status <> 2 HPSleep(200)
            IF deBug PRINT "                 \r";
            GOSUB ResetWatchDogTimer    // Restart the watchdog timer
        WEND
        GOSUB GetDate  // Recalculate date in case it's midnight and month (or year) has changed.
        IF deBug & i = 999 PRINT
        STORE msg_pointer, "",cast_mode$,"Beginning Cast Number ", cast_count + 1 : GOSUB LogMessage
        cast_mode$ = "Cast: " // used to prepend messages
        //--------Generate data file header----------------------------------------------------------------
        data_file_ptr = DATA_PTR_BEGIN - 100  // This is the date for the wind record.
        RTIME : STORE data_file_ptr, "  ", #02, ?(4), "/", ?(3), "/20", ?(5), " ", #02, ?(2), ":", ?(1), ":00  ";
        data_file_ptr = DATA_PTR_BEGIN       // Move pointer to beginning of logfile
        STORE data_file_ptr, "\r\nProfile Time: ", #02, ?(2), ":", #02, ?(1), ":00"
        STORE data_file_ptr, "Profile Date: ", #02, ?(4), "/", #02, ?(3), "/", #04,2000+ ?(5)
        STORE data_file_ptr, "Profile Depth: ",#4.3F, water_depth_m!, " m, target:", #4.3F, depth_target!," m"
        STORE data_file_ptr, "Profile Location: ",PROFILER_LOCATION$,  " Serial No: ",SONDE_SN$, ", ID: ",SONDE_ID$
        STORE data_file_ptr, "para: ", SONDE_PARA$
        STORE data_file_ptr, "Sonde data Status: ";
        IFF SONDE_FILTERING
            STORE data_file_ptr, "Filtered"
        ELSE
            STORE data_file_ptr, "Unfiltered"
        ENDIF
        // Now record the last load voltage recorded.
        STORE data_file_ptr, "Voltage (idle,load): ",voltage_idle!,  " , ",voltage_load!,"v"
        //-----Lower sonde to the bottom while recording data and monitoring:-----------------------
        //     Clicks and sonde_depth, motorAmps. Stop when either clicks reached
        //     calculated target or sonde_depth reaches target.
        GOSUB GetSondeDepth // What is our starting depth?
        STORE msg_pointer, "",cast_mode$,"Depth Margin:", #5.3F, DEPTH_MARGIN_M!, " m, at ", #3D, CLICKS_PER_M, " clicks per m" : GOSUB AppendMessage
        clicks_desired = INT((depth_target! - sonde_depth!) * CLICKS_PER_M)
        STORE msg_pointer, "",cast_mode$,"Lowering to ",#5.3F,depth_target!," m, or ",#3D, clicks_desired, " clicks from ",#5.3F,sonde_depth!," m." : GOSUB AppendMessage
        TSerInFlush(SONDE_IN_PORT) // clear the contents of the input port
        check_cond = 0 : sonde_logging = 'T'  // We are now logging sonde data
        sonde_conduct! = -9.999 : sonde_chlor! = -99.9 // For the sake of speed, we won't get conductivity or chlorophyl during cast.
        IF SONDE_FILTERING HPSleep(0) : HPSleep(1000) // allow 10 seconds of buffer to build up
        IFF cast_status = 0
            STORE msg_pointer, "",cast_mode$,"Aborting cast" : GOSUB LogMessage
            //GOTO The_Main_Loop // This only happens if we've had a serious error during previous move and the cast is aborted.
        ELSE
            GOSUB MotorRun
        ENDIF
        IF SONDE_FILTERING HPSleep(0) : PRINT "Collecting final 10 sec of data after moving" : HPSleep(1000)
        IF deBug PRINT "dumping sonde cache lines";
        WHILE TSerByteAvail(SONDE_IN_PORT) >= DATA_BUFFER
            GOSUB LogSondeData                // Get the buffered data and STORE() it
            IF deBug PRINT".";
        WEND
        IF deBug PRINT
        sonde_logging = 'F'  // We are no longer logging sonde data
        // We are at the bottom. -------------------------------------------------------------------
        GOSUB GetWindData    // collect current wind data if buffer is over half full
        STORE msg_pointer, "",cast_mode$,"Reached the bottom of cast ",#3D, cast_count + 1;
        STORE msg_pointer, " on click ",clicks_counted," of ",#4D, clicks_desired,"." : GOSUB LogMessage
        STORE msg_pointer, "",cast_mode$,"Depth reached: ",#5.3F,sonde_depth!," m. Target: ",#5.3F,depth_target!," m." : GOSUB AppendMessage
        data_file$ = STR(todays_date)+".dat"
        IF todays_date > 20500000 data_file$="default.dat" // we haven't set the date correctly
        temp_INT = CFSave(data_file$, data_file_ptr - DATA_PTR_BEGIN,DATA_PTR_BEGIN,1)   // Record sonde data in memory to CF card.
        IFF temp_INT < 1
            GOSUB GetCFerrorCodes // Get error code from temp_INT into temp_STR
            STORE msg_pointer, "Failed to write to data file (", data_file$, ") ERROR: ",temp_STR, ". Writing to default.dat." : GOSUB LogMessage
            data_file$ = "default.dat"
            temp_INT = CFSave(data_file$, data_file_ptr - DATA_PTR_BEGIN,DATA_PTR_BEGIN,1)
            IFF temp_INT < 1
                GOSUB GetCFerrorCodes // Get error code from temp_INT into temp_STR
                temp_STR$ = "Failed to write to:" + data_file$ + ". ERROR: " + temp_STR + ". "
                sms_msg$ = sms_msg$ + temp_STR$ // this will send SMS message at end of cast
                STORE msg_pointer, "ERROR: ",temp_STR$ : GOSUB LogMessage
            ENDIF
        ELSE
            STORE msg_pointer, "",cast_mode$,"Saved ", temp_INT, " of ", data_file_ptr - DATA_PTR_BEGIN, " bytes to file ", data_file$, "." : GOSUB LogMessage
        ENDIF
        //data_file_ptr = DATA_PTR_BEGIN     // Reset data_file_ptr now that the log messages have been saved
        IFF cast_status <> 0 // All's well, time to bring the sonde home
            IF clicks_counted > 0 retrieve_count = clicks_counted
            cast_mode$ = "Parking: " // used to prepend motor messages
            GOSUB ParkSonde
            // This would be a good place to check calibration again
            GOSUB CheckSondeCalibration // Leaves sonde off only if there was a calibration
        ELSE // Something went wrong
            STORE msg_pointer, "",cast_mode$,"Aborting cast" : GOSUB LogMessage
        ENDIF
        GOSUB StopSonde // In case there was no calibration
        GOSUB EncoderOff // Turn off the encoder now that the cast is done
        GOSUB GetWindData  // collect all wind data in buffer
        GOSUB FinishWind // Close wind port, flush port, perform calculations, and write to file on CF card. This must be done AFTER sonde data is recorded to CF card or sonde data will be corrrupted
        cast_count = cast_count + 1    // Increment cast counter
        GOSUB ResetWatchDogTimer
        KbFlush() // clear the console buffer
        PRINT "\n\rATE 0" : KbFlush() // turn off modem echo and flush input
        cast_status = 0 // The cast is done, so reset cast_status flag
        PRINT "Command:";
    ENDIF
    IFF cast_status = 0 // It is not time to cast, look for console interaction
        IFF KbHit()
            GOSUB Console // Get the character and go to console mode
        ENDIF
        SLEEP 0 : SLEEP 20 // Need a little sleep here to slow down loop and save power
    ENDIF
    IF ?(0) = 0 GOSUB ResetWatchDogTimer // reset watchdog timer every minute on the minute.
WEND // End of main loop.

//-----------------------------------------------------------------------------\
//                 The_Main_Loop ENDS                                          |
//-----------------------------------------------------------------------------/

//-----------------------------------------------------------------------------\
//              SUBROUTINE SECTION BEGINS                                      |
//                                                                             |
//                 Messaging                                                   |
//                    LogMessage                                               |
//                    AppendMessage, BasicMessage, LogContinue                 |
//                    DataSend (send a string to the sonde or wind)            |
//                    GetDataStr (Read output of sonde or wind)                |
//                    CheckSMS                                                  |
//                 Sonde Control Section                                       |
//                    InitializeSonde                                          |
//                    SetDataSonde                                             |
//                    SetDateFromSonde                                         |
//                    CheckSondeCalibration (Calibrate Depth Instrument)       |
//                    CalibrateSonde                                           |
//                    GetSondeDepth                                            |
//                    LogSondeData                                             |
//                    StartSondeSampling                                       |
//                    IsSondeRunning                                           |
//                    ParkSonde                                                |
//                    StopSonde (Stop sonde sampling)                          |
//                 Digital I/O and Motor routines                              |
//                    EncoderOff, EncoderOn, MotorOff, MotorUp, MotorDown,     |
//                    MotorRun                                                 |
//                    PingerOff, PingerOn                                      |
//                    MotorWatcher                                             |
//                    LowCurrent                                               |
//                    ReHome                                                   |
//                    WaterLineDock                                            |
//                 Depth Sounder (pinger) Related                              |
//                    InitializeDepth                                          |
//                    GetDepth                                                 |
//                    SortDepthIndex                                           |
//                    ResetPingArray                                          |
//                 Wind Related routines                                       |
//                    InitializeWind                                           |
//                    GetWindData                                              |
//                    ParseWindData                                            |
//                    FinishWind                                               |
//                    SetDataWind                                              |
//                 Reset, Shutdown, and Misc. Routines                         |
//                    OpenPort                                                 |
//                    Console                                                  |
//                    SubConsole                                               |
//                    ConsoleHelp                                              |
//                    PartialDL                                                |
//                    GetFileSize                                              |
//                    GetDate                                                  |
//                    ReadSetupIni                                             |
//                    ParseVariables                                           |
//                    CastCheck                                                |
//                    LaunchCheck                                              |
//                    ResetWatchDogTimer                                       |
//                    TrimStr                                                  |
//                    GetCFerrorCodes                                          |
//                    ErrorCheck                                               |
//                    Stoppage                                                 |
//                    StopNow                                                  |
//                 ISCO Routines                                               |
//                    ISCOscheduleRead                                         |
//                    ISCOcheck                                                |
//                    ISCOcast                                                 |
//                    ISCOrun                                                  |
//                                                                             |
//----------------------------------------------------------------------------/

//-----------------------------------------------------------------------------\
//       Messaging                                                            |
//  There are three message styles:
//      LogMessage      - Inserts message prepended with date & time
//      AppendMessage   - Inserts message with enough spaces prepended to line up with above message.
//      BasicMessage    - Inserts message.
LogMessage:
    // Read Only Variables: todays_date
    // Modified Global Variables: msg_log_file, msg_pointer
    // Modified Local Variables: msg_begin, temp_INT (restored), temp_STR
    // Uses temp_INT & temp_STR (if there is an error)
   msg_log_file$ = STR(todays_date) + ".log"
   IF todays_date > 20500000 msg_log_file$ = "startup.log" // we haven't set the date correctly
   // Store Date to Data File
   msg_begin = 1 : RTIME : STORE msg_begin,"20",#02,?(5),"/",?(4),"/",?(3)," ",?(2),":",?(1),":",?(0)," ";
   msg_begin = 1
   GOTO LogContinue     //This skips over AppendMessage

AppendMessage:
    msg_begin = 1 : STORE msg_begin,"                    "; // Prepend the spaces so that everything lines up
    msg_begin = 1
    GOTO LogContinue

BasicMessage:
    msg_begin = MSG_STR_BEGIN // instead of starting at address 1, start at 21 to allow for date stamp
    msg_pointer = msg_pointer - msg_begin + 1 // need to correct the total message length THIS IS WRONG

LogContinue:
    IF deBug & command_done <> 'F' temp_INT = msg_begin : OTEXT temp_INT  // This will print the message to the screen. It would be nice to skip this for certain Console messages.
    // Save it to file. If file exists, it will append.
    temp_INT = CFSave(msg_log_file$, msg_pointer - 1, msg_begin, 1)
    IFF temp_INT < 1
      msg_pointer = msg_pointer + msg_begin - 1 // Move pointer back to end...
      GOSUB GetCFerrorCodes // Get error code from temp_INT into temp_STR
      STORE msg_pointer, "Failed to write to (" + msg_log_file$ +  ") ERROR: " + temp_STR + ". Writing to DEFAULT.LOG" // generate error message... //  Append more information about failure
      IF deBug temp_INT = msg_begin : OTEXT temp_INT  // This will print the message to the screen
      msg_pointer = msg_pointer - msg_begin + 1 // need to correct the total message length again
      msg_log_file$ = "default.log"
      temp_INT = CFSave(msg_log_file$, msg_pointer-1, msg_begin, 1)
      IFF temp_INT < 1
          GOSUB GetCFerrorCodes // Get error code from temp_INT into temp_STR
          PRINT "ERROR: Write to DEFAULT.LOG failed:", msg_log_file$, ". ERROR: ",temp_STR
      ELSE
          IF deBug PRINT "Write to DEFAULT.LOG Successful."
      ENDIF
    ENDIF
    msg_pointer = MSG_STR_BEGIN // Reset the message pointer for the next message
    RETURN

DataSend:
// expects data_send_str$ Writes this to data_out_port which needs to be set appropriately
// also uses data_in_port and data_sleep_time. Clears data_reply
    data_send_ASCII$ = ""  // LOCAL This is the string to be sent to the sonde (in ASCII decimal)
    temp_STR$ = "A"       // LOCAL to hold string value of character to send
    temp_INT = 0         // LOCAL to hold decimal value of character to send
    data_reply$ = ""    // Clear the reply string. Were not interested in anything there.
    pointer_address = ConvertVarPtr(temp_STR$)   // find the address of this variable
    // Convert a string of characters to a string of decimal ascii equivalents.
    FOR i = 1 TO LEN(data_send_str$)  // Loop through once for each character in data_send_str
        temp_STR$ = MID(data_send_str$,i,1)  // Grab one character at a time starting from the left without changing data_send_str
        temp_STR$ = STR(PEEK(pointer_address + 1))             // convert value to a string
        WHILE LEN(temp_STR$) < 3                  // Pad with 0 to length 3 if needed
            temp_STR$ = "0" + temp_STR$
        WEND
        data_send_ASCII$ = data_send_ASCII$ + temp_STR$
    NEXT i
    HPSleep(0) : HPSleep(data_sleep_time)        // If anything is still coming, give it a second to finish
    // Now Flush the sonde IO if appropriate.
    IF data_in_port  = SONDE_IN_PORT  & TSerByteAvail(data_in_port) > 0 TSerInFlush(data_in_port) // clear the contents of the port
    IF data_out_port = SONDE_OUT_PORT & TSerByteAvail(data_out_port) > 0 TSerInFlush(data_out_port) // clear the contents of the port
    // Break data_send_ASCII into individual components, then send them using TSerPutByte
    REPEAT
        temp_STR = LEFT(data_send_ASCII$,3) // Get left three digits
        data_send_ASCII$ = RIGHT(data_send_ASCII$, LEN(data_send_ASCII$) - 3) // then remove those digits
        temp_INT = VAL(temp_STR) // conver string to decimal
        IFF temp_INT > 0  // There shouldn't be any nulls
            TSerPutByte(data_out_port,temp_INT)
            HPSleep(0) : HPSleep(10)  // Slowing it down a little makes writes go better
        ENDIF
    UNTIL LEN(data_send_ASCII$) = 0
    RETURN

GetDataStr:
    // Read Only Variables: motor_running, sonde_logging, data_in_port, data_sleep_time
    // Modified Global Variables: data_reply, data_reply_full
    // Modified Local Variables: temp_STR, pointer_address, temp_INT
    // data_reply$ can have up to 256 characters when motor is not running. If
    // more, data_reply_full will be 'T'. If the motor is running, data_reply
    // will end in the next \n.
    //
    // Wait a while to transmit unless we already have data in the buffer
    IFF data_reply_full = 'F' & motor_running = 'F' & sonde_logging = 'F'
        // If the motor isn't running (probably during console), slow things down
        IF TSerByteAvail(data_in_port) = 0 HPSleep(0) : HPSleep(data_sleep_time)
    ENDIF
    temp_STR$ = "A" // LOCAL to hold string value of character received
    pointer_address = ConvertVarPtr(temp_STR$) // Get our memory address
    temp_INT = 0    // LOCAL to hold decimal value of character received
    data_reply_full = 'F' // reset GLOBAL to not full
    data_reply$ = "" // Clear GLOBAL variable
    // If the motor is NOT running, we will get everything in the buffer
    // If the motor IS running, we exit when we get a CR or DATA_BUFFER characters
    WHILE TSerByteAvail(data_in_port) > 0 // Can also escape with RETURNs below...
        temp_INT = TSerGetByte(data_in_port)  // Get the next byte from the data_in_port
        // Some special Characters:
        //   8 = BackSpace
        //  10 = LineFeed or \n
        //  13 = Carriage Return or \r
        IFF ( temp_INT <> 8 )  // ignore backspaces SHOULD WE IGNORE OTHER CHARACTERS?
            // now convert this dec to a str using poke
            POKE pointer_address + 1, temp_INT
            // Append this character to our string
            data_reply$ = data_reply$ + temp_STR$
            // Now check our RETURN conditions....
            IFF (motor_running <> 'F' | sonde_logging = 'T') // IF the motor is running OR we are logging, we only want one line at a time.
            IFF temp_STR = "\n" // When motor running, stop when we get to LF (changed \r to \n)
                IFF LEN(data_reply$) > DATA_BUFFER + 10 // Which shouldn't have more than DATA_BUFFER characters
                    STORE msg_pointer, "DATA_BUFFER overrun, ", LEN(data_reply$)," > ", DATA_BUFFER," with ",TSerByteAvail(data_in_port)," bytes in buffer" : GOSUB LogMessage
                ENDIF
                RETURN //escape from While loop
            ENDIF
            ENDIF
            IF LEN(data_reply$) >= 255 data_reply_full = 'T' : RETURN // string is too long, escape from WHILE loop
        ENDIF
    WEND
    RETURN

CheckSMS:
    // Expects sms_msg and SMS_ADDRESS.
    // First Initializes the modem then sends the appropriate command strings
    IF sms_msg$ = "" RETURN
    sms_msg$ = "AVP" + STR(PROFILER_NUMBER) + ": " + sms_msg$
    STORE msg_pointer, "Sending ", SMS_ADDRESS$, " SMS: ", sms_msg$ : GOSUB LogMessage
    sms_msg$ = LEFT(sms_msg$,160) // max SMS message length of 160
    PRINT "Press Esc|ctrl-x to skip SMS"
    key_pressed = 0 : i = 20
    REPEAT // This allows user to skip this if in interactive more
        HPSleep(0) : HPSleep(25)
        i = i - 1
        IF KbHit() key_pressed = KbChar()// If there is a character from the keyboard
        IFF (key_pressed = 24 | key_pressed = 27)
            PRINT "Skipping"
            sms_msg$ = ""
            RETURN
        ENDIF
    UNTIL i <= 0
    PRINT "ATE 0" : KbFlush()
    PRINT "AT\r\nAT\r\nAT+CMGS=",SMS_ADDRESS$  // enter command and delivery address
    REPEAT // wait for a ">"(ascii 62), esc, ctrl-x or until we timeout. i should be 0 from above
        HPSleep(0) : HPSleep(100) : i = i + 1
        IF KbHit() key_pressed = KbChar() // key_pressed is the integer ascii code for character entered
    UNTIL i > 20 | key_pressed = 24 | key_pressed = 27 | key_pressed = 62
    PRINT sms_msg$,"\r\nAT,\r\nAT"
    sms_msg$ = "" // Clear sms
    KbFlush() // flush keyboard again.
    RETURN
//------- End Messaging -------------------------------------------------------/
//-----------------------------------------------------------------------------
//       Sonde Control Section                                                 \
//                    InitializeSonde                                          |
//                    SetDataSonde                                             |
//                    SetDateFromSonde                                         |
//                    CheckSondeCalibration (Calibrate Depth Instrument)       |
//                    CalibrateSonde                                           |
//                    GetSondeDepth                                            |
//                    LogSondeData                                             |
//                    StartSondeSampling                                       |
//                    IsSondeRunning                                           |
//                    ParkSonde                                                |
//                    StopSonde (Stop sonde sampling)                          |

InitializeSonde:
    cast_mode$ = "Sonde: "
    sub_arg(1) = 3 // High Priority
    sub_arg(4) = SONDE_BAUD
    // Now output
    sub_arg(0) = SONDE_OUT_PORT
    sub_arg(2) = 1 // 1 = Output
    sub_arg(3) = SONDE_OUT_BUFFER
    GOSUB OpenPort
    // Now input
    sub_arg(0) = SONDE_IN_PORT
    sub_arg(2) = 0 // 0 = Input
    sub_arg(3) = SONDE_IN_BUFFER
    GOSUB OpenPort
    GOSUB StopSonde // Stop the sonde if it is running when we open it.
    GOSUB SetDateFromSonde  // Now set the date from sonde
    data_send_str$ = "setecho 0\r\n" : GOSUB DataSend : PRINT "Echo Off"    // Echo should still be off from SetDateFromSonde...
    data_send_str$ = "setpage 0\r\n" : GOSUB DataSend : PRINT "Page length 0"   // Set page size to 0
    data_send_str$ = "setid\r\n" : GOSUB DataSend : GOSUB GetDataStr   // Get ID information and parse
    SONDE_ID$ = LEFT(data_reply$,(INSTR(data_reply,"\n") - 2))
    data_send_str$ = "sn\r\n" : GOSUB DataSend : GOSUB GetDataStr   // Get Sonde 8 digit SN information and parse
    SONDE_SN$ = LEFT(data_reply$,8)
    //IF LEN(SONDE_ID$) = 0 SONDE_ID$ = SONDE_SN$ // Set the ID to the serial number if there is no ID
    STORE msg_pointer, "YSI ID: ", SONDE_ID$, " SN: " + SONDE_SN$ + ".": GOSUB LogMessage
    data_send_str$ = "sinterval 1\r\n" : GOSUB DataSend : PRINT "1 Hz sampling"  // Set sample interval to one second
    data_send_str$ = "twipeint 0\r\n" : GOSUB DataSend : PRINT "No auto wipes"  // Sets the wipe interval to 0 (manual only)
    data_send_str$ = "numtwipe 1\r\n" : GOSUB DataSend : PRINT "1 wipe/request"  // Sets the number of wipes to 1
    data_send_str$ = "flton " + STR(SONDE_FILTERING) + "\r\n" : GOSUB DataSend : PRINT "Filter on = ", SONDE_FILTERING
    data_send_str$ = "measure 1\r\n" : GOSUB DataSend : PRINT "Autosleep off"   // Turn off autosleep
    data_send_str$ = "para\r\n" : HPSleep(0) : GOSUB DataSend : PRINT "Report param..."; : HPSleep(200)  //Check the report parameters
    GOSUB GetDataStr // We need the response for this one
    data_send_str$ = data_reply$ : temp_INT = 3 : GOSUB TrimStr // Do an AllTrim on data_send_str
    SONDE_PARA$ = data_reply$
    DATA_REPLY_LEN = 0
    IFF INSTR(SONDE_PARA$,"52 54 1 6 12 15") > 0
        PRINT "6600 sonde"
        DATA_OFFSET_COND = 20     // Offset from DATA_OFFSET_DEPTH
        DATA_OFFSET_CHLOR = 6     // Offset from CR
        IFF INSTR(SONDE_PARA$,"22 203 193") > 0
            STORE msg_pointer, " 6600 (no pH)" : GOSUB LogMessage
            DATA_OFFSET_DEPTH = 22    // Offset from CR
            DATA_REPLY_LEN = 68       // Length of a line of data
        ENDIF
        IFF INSTR(SONDE_PARA$,"22 37 193") > 0
            STORE msg_pointer, " 6600 (no pH) w/old turbid" : GOSUB LogMessage
            DATA_OFFSET_DEPTH = 21    // Offset from CR
            DATA_REPLY_LEN = 67       // Length of a line of data
        ENDIF
        IFF INSTR(SONDE_PARA$,"22 18 203 193") > 0
            STORE msg_pointer, " 6600 w/pH" : GOSUB LogMessage
            DATA_OFFSET_DEPTH = 28    // Offset from CR not 27
            DATA_REPLY_LEN = 74       // Length of a line of data
        ENDIF
    ENDIF
    IFF INSTR(SONDE_PARA$,"52 54 1 6 12 22 18 203 193 212") = 1
        STORE msg_pointer, " 6600v2 (with pH)." : GOSUB LogMessage
        DATA_OFFSET_DEPTH = 35    // Offset from CR
        DATA_OFFSET_COND = 13     // Offset from DATA_OFFSET_DEPTH
        DATA_OFFSET_CHLOR  = 13   // Offset from CR
        DATA_REPLY_LEN = 74       // Length of a line of data
    ENDIF
    IFF (DATA_REPLY_LEN = 0) // No matches found
        temp_STR$ = "WARNING! unknown report:" + SONDE_PARA$ + "."
        STORE msg_pointer, "", temp_STR$ : GOSUB LogMessage
        sms_msg$ = sms_msg$ + temp_STR$
    ENDIF
    data_send_str$ = "setecho 1\r\n" : GOSUB DataSend : PRINT "Echo on"   // Set echo back on...
    RETURN
//-------End InitializeSonde Subroutine------------------------------------------------

SetDataSonde: // Puts data subroutines in sonde mode rather than wind mode.
    data_in_port = SONDE_IN_PORT
    data_out_port = SONDE_OUT_PORT
    RETURN

SetDateFromSonde:
    GOSUB IsSondeRunning : IF sonde_running <> 'F' GOSUB StopSonde // Can't set the date from a running sonde.
    FOR i = 1 to 3 // We will try three times.
        GOSUB SetDataSonde // put us in sonde mode for Data routines
        // Get the date,time from the sonde
        // Set the TT8s time based on the sonde time
        sonde_date$     = "01/01/01"  // LOCAL to hold date from sonde
        sonde_time$     = "01:00:00"  // LOCAL to hold time from sondeGOSUB StopSonde
        data_send_str$ = "setecho 0 \r\n" : GOSUB DataSend : IF deBug PRINT "Echo off"
        // Get the time
        data_send_str$ = "\n\rtime\r\n" : GOSUB DataSend
        GOSUB GetDataStr   // Get information and parse
        sonde_time = LEFT(data_reply,8)
        // Now set the internal clock
        ?(0) = VAL(RIGHT(sonde_time,2))   // second
        IF ?(0) > 59 | ?(0) <  0 ?(0) = 0
        ?(1) = VAL(MID(sonde_time,4,2))  // minute
        IF ?(1) > 59 | ?(1) <  0 ?(1) = 0
        ?(2) = VAL(LEFT(sonde_time,2))    // hour
        IF ?(2) > 23 | ?(2) <  0 ?(2) = 0
        // Get the date
        data_send_str$ = "date\r\n" : GOSUB DataSend
        GOSUB GetDataStr   // Get information and parse
        sonde_date = LEFT(data_reply,8)
        ?(3) = VAL(MID(sonde_date,4,2))   // day
        IF ?(3) > 31 | ?(3) <= 0 ?(3) = 1
        ?(4) = VAL(LEFT(sonde_date,2))    // month
        IF ?(4) > 12 | ?(4) <= 0 ?(4) = 1
        ?(5) = VAL(RIGHT(sonde_date,2))   // year
        IFF ?(5) <= 25 // make sure we got a valid year value (this will fail after the year 2025)
            STIME : RTIME          // Set the time into the real-time clock
            STORE msg_pointer, "Time set to ", #02, ?(2), ":", ?(1), ":", ?(0), " EST";
            STORE msg_pointer, " on ", #02, ?(4), "/", ?(3), "/20", ?(5) : GOSUB LogMessage
            todays_date = 20000000 + (?(5) * 10000) + (?(4) * 100 ) + ?(3)
            IFF todays_date <> VGET(0)
                VSTORE 0,todays_date
                STORE msg_pointer,  "Date, ",todays_date, " stored to EEPROM(0).": GOSUB LogMessage
            ENDIF
            RETURN // this will get us out of the FOR NEXT LOOP
        ELSE
            RTIME // restore from system clock ignoring new values
            STORE msg_pointer, "ERROR: No sonde comms. Attempt ",i : GOSUB LogMessage
        ENDIF
    NEXT i
    RETURN

CheckSondeCalibration:
    // Starts sonde, checks calibration parameters and calibrates if necessary. Leaves sonde turned off if a calibration occured.
    GOSUB StartSondeSampling
    GOSUB ResetWatchDogTimer    // restart the watchdog timer
    GOSUB GetSondeDepth
    IFF sonde_conduct! > saltwater_cond! | sonde_conduct! = -8.888 // We in the water (conductivity)?
        IFF sonde_depth! > SONDE_D_DB! // And in the water (pressure)
            STORE msg_pointer, "ERROR: Cond. > ",#5.2F,saltwater_cond!," and press. of ",#5.3F,sonde_depth!,". No re-cal." : GOSUB LogMessage
        ELSE // We have conductivity, but not pressure, so we are probably at the WL.
            IFF (sonde_depth! < (SONDE_D_DB! * -1))
                // This may not fix it, but will proabbly improve the situation
                STORE msg_pointer, "ERROR: Large negative sonde pressure indicates erroneous calibration may have occured!" : GOSUB LogMessage
                GOSUB CalibrateSonde
                GOTO CheckSondeCalibration // If it worked, we will quickly exit this routine
            ELSE
                STORE msg_pointer, "ERROR: Press. within specs despite cond. of ",#6.3F,sonde_conduct!,". No re-cal." : GOSUB LogMessage
            ENDIF
        ENDIF
    ELSE // We are out of the water
        IFF ABS(sonde_depth!) <= SONDE_D_DB! // And still calibrated
            STORE msg_pointer, "",cast_mode$,"Pressure within \xB1 ",#5.3F,SONDE_D_DB!," of 0, no cal. required." : GOSUB LogMessage
        ELSE // Pressure has drifted...
            GOSUB CalibrateSonde
            GOTO CheckSondeCalibration // If it worked, we will quickly exit this routine via a RETURN
        ENDIF
    ENDIF
    RETURN

CalibrateSonde:
    IF (sonde_depth! < (SONDE_D_DB! * -3)) STORE msg_pointer, "ERROR: Neg. press. Bad cal. may have occured" : GOSUB LogMessage
    GOSUB SetDataSonde // put us in sonde mode for Data routines
    IF deBug PRINT "Re-calibrating sonde depth. ";
    GOSUB StopSonde // Stop the sonde if it is running when we open it.
    HPSleep(0) : IF deBug PRINT "Waiting for sonde to stop..." : HPSleep(200)
    data_send_str$ = "\r\ncalibrate 3 0.000\r\n" : GOSUB DataSend // Enter Depth of 0.000
    STORE msg_pointer, "INIT: Calibrated depth to 0 from ",#6.3F, sonde_depth!, "m with Cond. of ",#6.3F,sonde_conduct!," mS/cm." : GOSUB LogMessage
    IF deBug PRINT "Pausing for calibration to settle ";
    FOR i = 10 to 1 step -1
        HPSleep(0) : PRINT i," ";
        HPSleep(100)
    NEXT i
    PRINT
    RETURN

GetSondeDepth:
    // Read Only Variables: sonde_logging, motor_running. SUB: data_sleep_time
    // Modified Global Variables: sonde_depth, sonde_conduct, sonde_chlor. SUB: data_in_port, data_out_port, data_reply_full
    // Modified Local Variables: data_reply, temp_INT, temp_STR, temp_FLT, previous_pointer. SUB: pointer_address
    GOSUB SetDataSonde // put us in sonde mode for Data routines
    // First Reads the sonde buffer or STOREd memory and extracts the depth field to sonde_depth! variable
    IFF sonde_logging = 'F'  // We aren't STOREing so not during a cast
        // Should ONLY be called if there are > DATA_BUFFER characters in buffer
        // Use GetDataStr to get the data
        // Get the next line off of the buffer
        data_reply$ = ""
        GOSUB GetDataStr  // Returns data_reply$
    ELSE // We are STOREing during a cast so use GETS() to get the data
        // data_reply$ should have contents from previous call to LogSondeData
        IFF INSTR(data_reply$,"\r") < DATA_OFFSET_DEPTH    // If there aren't enough, use GETS() to retrieve STOREd data.
             //IF deBug=2 PRINT "Using GETS() to extract depth data"
             previous_pointer = previous_pointer + 1 // skip the first "\n" character
             data_reply$ = GETS(previous_pointer) // this should give us at least the last 29 or 40 characters
             // NOTE: this data was STOREd using form 2 which doesn't put in a length
             // byte. The first character should be long enough to act as a length
             // byte and return all the data we need.
        ENDIF
    ENDIF
    // We should now have a line of sonde data in data_reply. Now to parse the value we extracted
    temp_INT = INSTR(data_reply$,"\r")  // Locate first and usually only CR
    IFF temp_INT >= DATA_OFFSET_DEPTH // there are enough (22 or 35) characters before the CR to contain depth
        temp_STR$ = MID(data_reply$,temp_INT - DATA_OFFSET_DEPTH,8)  // Depth is eight characters, 22 or 35 places before the CR."
        temp_FLT! = VAL(temp_STR$)      // convert to a float and check validity...
        // The depth parsed must have a decimal in it and be within 0.500 m of deepest depth encountered so far.
        IFF INSTR(temp_STR$,".") & (temp_FLT! < ABS((max_depth_m! + 0.500))) // Now that it has passed the tests, set the new sonde_depth and increment counter
            sonde_depth! = temp_FLT!
            sonde_samples = sonde_samples + 1
            // If we are deeper than expected minimums, reset some counters.
            IF sonde_depth! > sonde_depth_max! sonde_depth_max! = sonde_depth! // Reset maximum sonde depth.
        ENDIF
        // now lets get the conductivity and perhaps chlorophyl
        sonde_conduct! = -9.999 : sonde_chlor! = 99.9// Default values...
        IFF temp_INT >= (DATA_OFFSET_DEPTH + DATA_OFFSET_COND)  // Conductivity is DATA_OFFSET_COND (21 or 13) characters before depth
            temp_STR$ = MID(data_reply$,temp_INT - (DATA_OFFSET_DEPTH + DATA_OFFSET_COND),6) // Six characters (XX.XXX)
            IF INSTR(temp_STR$,".") sonde_conduct! = VAL(temp_STR$) // Now set the new sonde conductivity if we have a decimal point
            IFF sonde_logging = 'F' | motor_running = 'F' // If we aren't logging or the motor is stopped, parse more data.
                temp_STR$ = MID(data_reply$,temp_INT - DATA_OFFSET_CHLOR,5) // chlor is five characters
                IF INSTR(temp_STR$,".") sonde_chlor! = VAL(temp_STR$) // There must be a decimal // Now set the new sonde conductivity
            ENDIF
        ELSE // Put in dummy values to indicate bad data
            sonde_conduct!  = -8.888 : sonde_chlor! = 88.8
        ENDIF
        IF motor_running <> 'F' GOSUB MotorWatcher // check clicks yet again
    ENDIF
    RETURN

LogSondeData: // Gets one line of data from the sonde buffer and STOREs it
    // Increments log_datas_ptr and returns previous_pointer
    GOSUB SetDataSonde // put us in sonde mode for Data routines
    // check to see if there is any data available
    temp_sleep_time = data_sleep_time // LOCAL to hold the original
    data_sleep_time = 1  // we shouldn't need to sleep in this mode
    data_reply_full = 'F' // Reset to 'T'. If the variable is not full, GetDataStr will set it to 'F'
    GOSUB GetDataStr  // gets a line from the buffer and returns it as data_reply$
    IF motor_running <> 'F' GOSUB MotorWatcher // check for click again
    previous_pointer = data_file_ptr // save previous pointer value to extract depth later with GETS()
    // could check length of data_reply$ here and discard is less than expected.
    IFF LEN(data_reply$) = DATA_REPLY_LEN
        STORE data_file_ptr, "", data_reply$; // The "" puts the STORE in form 2 which doesn't store length bytes
    ELSE
        IFF LEN(data_reply$) > DATA_REPLY_LEN
            data_reply$ = RIGHT(data_reply$,DATA_REPLY_LEN)
            STORE data_file_ptr, "", data_reply$; // If it's too long, trim and STORE
        ENDIF
       // does nothing with short strings.
    ENDIF
    // Return data_sleep_time to its original value
    data_sleep_time = temp_sleep_time
    RETURN

// Logs in to sonde, and puts us in sampling mode.
// It then allows the buffer to fill partialy and then clears it to good sampling data.
StartSondeSampling:
    GOSUB IsSondeRunning
    IF sonde_running = 'T' RETURN // No need to start it!
    IF deBug PRINT "STARTUP: Starting sonde sampling... ";
    GOSUB SetDataSonde // put us in sonde mode for Data routine
    // Get out to the # prompt where we should already be
    GOSUB StopSonde // Get to the # prompt on the sonde
    // Make sure our time constant is 4
    IFF SONDE_FILTERING
        IF deBug STORE msg_pointer, "Setting time constants and turning on filters..." : GOSUB AppendMessage
        data_send_str$ = "flttimec 4\r\n" : GOSUB DataSend
        data_send_str$ = "fltthresh 0.001\r\n" : GOSUB DataSend
        data_send_str$ = "flton 1\r\n" : GOSUB DataSend
    ENDIF
    // Make sure we're getting sonde_depth before leaving this....
    sonde_depth! = -9.999 : sonde_conduct! = -9.999 : sonde_chlor! = -99.9
    fail_count = 0 : temp_byte_count = 0 : sonde_depth_max! = 0.0
    IF deBug PRINT "Waiting for ",DATA_BUFFER," characters of data... ";
    REPEAT
        IFF fail_count = 0 | fail_count % 10 = 0 // First time and every 10 cycles thereafter, try this again
            IFF fail_count <> 0
                STORE msg_pointer, "ERROR: Timeout (",fail_count,") while initiating sonde data, trying again..." : GOSUB LogMessage
                GOSUB ResetWatchDogTimer    // restart the watchdog timer
                GOSUB StopSonde
            ENDIF
            IF deBug PRINT "Entering RUN mode... ";
            data_send_str$ = "\r\nRUN\r\n" : GOSUB DataSend
            TSerInFlush(SONDE_IN_PORT) // clear the contents of the port
        ENDIF
        IFF fail_count > 50
            temp_STR$ = "No sonde comms, aborting on cast " + STR(cast_count + 1 ) + " in " + cast_mode$
            sms_msg$ = sms_msg$ + temp_STR$
            STORE msg_pointer, "ERROR: ", temp_STR$  : GOSUB LogMessage
            cast_status = 0 // This should abort cast
            GOSUB CheckSMS
            // Get out to the # prompt
            GOSUB StopSonde
            RETURN // Exit this subroutine
        ENDIF
        IF temp_byte_count = TSerByteAvail(SONDE_IN_PORT) fail_count = fail_count + 1
        HPSleep(0) : HPSleep(100)  // wait for more characters
        temp_byte_count = TSerByteAvail(SONDE_IN_PORT)
    UNTIL  TSerByteAvail(SONDE_IN_PORT) >= DATA_BUFFER  // Wait for DATA_BUFFER characters
    // get rid of all but the last entire line
    temp_STR$ = "A" // LOCAL to hold string value of character received
    pointer_address = ConvertVarPtr(temp_STR$) // Get our memory address
    REPEAT
        POKE pointer_address + 1, TSerGetByte(SONDE_IN_PORT)
    UNTIL (TSerByteAvail(SONDE_IN_PORT) < DATA_BUFFER & temp_STR$  = "\r") | TSerByteAvail(SONDE_IN_PORT) <= 0
    IF deBug PRINT "Initial values... ";
    fail_count = 0
    REPEAT
        HPSleep(0)
        IF TSerByteAvail(SONDE_IN_PORT) >= DATA_BUFFER GOSUB GetSondeDepth  // returns sonde_depth! & sonde_conduct! variables
        HPSleep(50)
        fail_count = fail_count + 1
    UNTIL (sonde_depth! >= -9 & sonde_conduct! >= -9) | fail_count > (CONSOLE_TIMEOUT * 2) // escapes after about 10 seconds if good values not detected.
    //IF deBug PRINT "SONDE DEPTH INITIATED with ",TSerByteAvail(SONDE_IN_PORT), " bytes on buffer and initial sonde depth of ",#6.3F, sonde_depth!
    IF deBug PRINT "Done."
    sonde_running = 'T'
    RETURN

IsSondeRunning:
    PRINT "Sonde Running?";
    sonde_running = 'F'
    TSerInFlush(SONDE_IN_PORT) // clear the contents of the port
    FOR i = 0 to 10
        HPSleep(0) : HPSleep(10)
        PRINT ".";
        IF TSerByteAvail(SONDE_IN_PORT) sonde_running = 'T' : PRINT " Yes" : RETURN
    NEXT i
    PRINT " No"
    RETURN

ParkSonde:
    // This subroutine will attempt to take the sonde from any location and put it in the parked position.
    // It assumes that the sonde is running but will turn it off when done
    // Read Only Variables: high_current, cast_mode, retrieve_count, clicks_counted, sonde_conduct, sonde_depth
    // Modified Global Variables:
    // Modified Local Variables: msg_pointer, dclicks_desired, check_cond, check_WL, depth_target, temp_clicks
    // the value in retrieve_count * 1.5 is used for raising
    // There are two parts to this, get the sonde to the surface, then park it.
    GOSUB StartSondeSampling // Make sure sonde is running
    IF (high_current = 'T')  STORE msg_pointer, "",cast_mode$, "No parking after high current." : RETURN
    GOSUB GetSondeDepth
    IFF sonde_depth! <= SONDE_WL_MIN! & sonde_conduct! <= saltwater_cond!
        STORE msg_pointer, "",cast_mode$, "Ambiguous position, lowering ",  HOME_TO_WL_COUNT, " clicks." : GOSUB LogMessage
        // We're at least partially out of the water or perhgaps all the way at the top
        // Let's go down a little to get a fresh start.
        depth_target = 0.1 // This should be deep enough
        clicks_desired = HOME_TO_WL_COUNT
        check_cond = 0 //: check_WL = 0 (not needed after 3.15)
        GOSUB MotorRun
    ENDIF
    STORE msg_pointer, "",cast_mode$, "Raising until surface detected by pressure & conductivity (or overcurrent)." : GOSUB LogMessage
    TSerInFlush(SONDE_IN_PORT) // clear the contents of the input port
    clicks_desired = ABS(retrieve_count) * -1.5 // Negative clicks_desired is for retrieval
    depth_target! = -99.999 // We don't want it stopping due to depth
    check_WL = 1 : check_cond = 1
    GOSUB MotorRun
    STORE msg_pointer, "",cast_mode$," At surface after ", clicks_counted, " of ", retrieve_count, " expected clicks. " : GOSUB LogMessage
    clicks_counted = 0 // no longer need clicks_counted
    // Raise sonde to HOME position.
    // Check to see we didn't have a high current condition.
    IFF  high_current <> 'T'
        STORE msg_pointer, "",cast_mode$," Raising from waterline to home pos." : GOSUB LogMessage
        clicks_desired = WL_TO_HOME_COUNT * -1 : temp_clicks = 0 : check_cond = 0 : check_WL = 0
        depth_target! = -9999 // We don't want it stopping due to depth
        GOSUB MotorRun // Dock the sonde
        STORE msg_pointer, "",cast_mode$," Home pos. after ", clicks_counted, " more clicks. "
    ELSE
       STORE msg_pointer, "",cast_mode$," No further retrieval after high current."
    ENDIF
    RETURN

StopSonde:    //Stop the sonde's sampling
    GOSUB SetDataSonde // put us in sonde mode for Data routines
    // Send an ESC to stop us running if we are or to wake up the instrument if asleep
    data_send_str$ = "\x1B" : GOSUB DataSend
    // Now another ESC and  CTRL-E to make sure we're at command line
    data_send_str$ = "\x1B\x05" : GOSUB DataSend
    HPSleep(0) : HPSleep(50) // Wait a quarter second.
    // Make sure our time constant is 0 for better response rates. Also turn off filter and set threshold to 0
    data_send_str$ = "flttimec 0\r\n" : GOSUB DataSend
    data_send_str$ = "fltthresh 0\r\n" : GOSUB DataSend
    data_send_str$ = "flton 0\r\n" : GOSUB DataSend
    HPSleep(0) : HPSleep(50) : TSerInFlush(SONDE_IN_PORT)
    IF deBug PRINT "Sonde turned off"
    sonde_running = 'F'
    RETURN
//-------End Sonde Control Section----------------------------------------------

//------------------------------------------------------------------------------
//       Digital I/O and Motor routines:
//          EncoderOff - Turns off Optical Encoder
//          EncoderOn
//          MotorOff - Turns off Motor
//          MotorUp
//          MotorDown
//          MotorRun
//          PingerOff
//          PingerOn
//          MotorWatcher
//          LowCurrent
//          ReHome
//          WaterLineDock
//       Pins:
//          2:Watchdog timer reset
//          3:Power to depth sounder (pinger)
//          4:Encoder Power (actually switched ground)
//          5:Lower Motor
//          6:Raise Motor
EncoderOff:
    clicks_counted = 0 // supress message from MotorOff. Wouldn't be using clicks_counted a this point
    PCLR 4 // Set pin 4 low
    RETURN
EncoderOn:
    //IF deBug PRINT "Turning click encoder on."
    PSET 4 // Set Pin 4 high
    RETURN
MotorOff:
    PCLR 5, 6 // Set Pins 5 and 6 low
    IFF clicks_counted > 0 & current_load > 0
        STORE msg_pointer, "",cast_mode, "Motor Off: ", #2, clicks_counted,"/",clicks_desired, " cl";
        STORE msg_pointer, ", SndDpth:",#6.3F, sonde_depth!,"/",#6.3F, depth_target!, " m. ",#4D, TSerByteAvail(SONDE_IN_PORT), " bytes" ;
        STORE msg_pointer, ", Cond:",#6.3F, sonde_conduct!, ", Power: ", #5.3F, current_load!, " A @ ",voltage_load!," V"
        GOSUB LogMessage
        // Check if last detected voltage was low while current wasn't high.
        IFF voltage_load! <= LOW_VOLTAGE! & current_load <= AMPS_NORMAL!
            STORE msg_pointer,  "POWER ERROR: Voltage, ",#5.2F,voltage_load!,"V at ",current_load!,"A is below alarm level of ",LOW_VOLTAGE!,"V"
            GOSUB AppendMessage
        ENDIF
    ENDIF
    motor_running = 'F' : boost_current = 'F'
    encoder_cycles = 0 : clicks_last_delta = 0
    COUNT // Stop counting clicks_counted
    max_current_load! = AMPS_NORMAL! // Return current alarm level to normal
    GOSUB ResetWatchDogTimer    // restart the watchdog timer
    RETURN
MotorUp:
    STORE msg_pointer, "",cast_mode, "Raising ",ABS(clicks_desired)," clicks or to ",#6.2F,depth_target!," m." : GOSUB LogMessage
    current_load! = 0.0
    clicks_counted = 0 : encoder_cycles = 0 : high_current = 'F'  // Reset some flags.
    motor_running = 'U'
    IF max_current_load! < AMPS_NORMAL!  max_current_load! = AMPS_NORMAL! // Raise max current alarm level at least to normal when raising
    clicks_counted = 0 : clicks_last_counted = 0 // Reset counters
    COUNT clicks_counted // Start counting clicks
    PCLR 5 : PSET 6       // Set Pin 6 High and 5 low
    StopWatchStart() // Used for cicker timeout
    RETURN
MotorDown:
    STORE msg_pointer, "",cast_mode, "Lowering ",ABS(clicks_desired)," clicks or to ",#6.3F,depth_target!," m." : GOSUB LogMessage
    current_load! = 0.0
    clicks_counted = 0 : encoder_cycles = 0 : high_current = 'F'  // Reset some flags.
    IF check_WL PRINT "No WL check on Decent" : check_WL = 0
    motor_running = 'D'
    max_current_load! = AMPS_NORMAL! // Lowering current alarm level always starts Normal
    clicks_counted = 0 : clicks_last_counted = 0 // Reset counters
    COUNT clicks_counted // Start counting clicks
    PCLR 6: PSET 5 // Set Pin 5 high and 6 low
    StopWatchStart() //Used for clicker timeout
    RETURN
MotorRun:
    // Expects clicks_desired. The sign of clicks_desired determines direction.
    //    If clicks_desired is positive, motor moves down (or away from home).
    //    If clicks_desired is negative, motor moved up (or towards home).
    // Expects check_WL
    // Expects check_cond
    // Expects sonde_depth! & depth_target!
    // Reads LAUNCH_CHECK_CLICKS, SONDE_IN_PORT, DATA_BUFFER
    // Motor will stop under the following conditions:
    //    when clicks_counted >= ABS(clicks_desired)
    //    we get a high current condition.
    //    We've reached our target depth
    //    Our conductivity indicates we are now in/out of the water IF check_cond = 1
    IFF ABS(clicks_desired) < 3000  & clicks_desired <> 0 // Check to make sure request is reasonable
        sonde_chlor = -99.9
        sonde_depth_last! = 0 : clicks_last_delta = DELTA_CLICKS * 2 // Don't check at the very top of the cast
        IF sonde_logging = 'F' & TSerByteAvail(SONDE_IN_PORT) TSerInFlush(SONDE_IN_PORT) // clear the contents of the sonde input port if we aren't logging
        IF clicks_desired > 0 GOSUB MotorDown
        IF clicks_desired < 0 GOSUB MotorUp
        WHILE motor_running <> 'F' // There are lots of conditions which will turn off the motor. It may get turned off more than once in a single loop which is OK
            GOSUB MotorWatcher // Check clicks and watch amps.
            IFF clicks_counted >= ABS(clicks_desired) // Turn the motor off if we've reached our click count
                STORE msg_pointer, "",cast_mode$,"Clicks counted(",clicks_counted,") >= desired (",ABS(clicks_desired),").": GOSUB LogMessage
                GOSUB MotorOff // We've reashed our click target
                check_WL = 0 : check_cond = 0 : RETURN // Turn off Conductivity check
            ENDIF
            // See if we are tangled, stuck, or on the bottom.
            // Every DELTA_CLICKS while lowering check if the current depth - the depth DELTA_CLICKS ago is less than DELTA_D_MIN (and we are in the water)
            temp_INT = clicks_counted // clicks_counted can change at any time so we store to temp_INT.
            IF sonde_depth_max! = sonde_depth! clicks_last_delta = temp_INT // This should reset window whenever the sonde reaches a new depth maximum.
            IFF INSTR(cast_mode$,"Cast") & temp_INT - clicks_last_delta >= DELTA_CLICKS // in Cast mode and DELTA_CLICKS have passed since last depth maximum
                clicks_last_delta = temp_INT // Don't repeat this click.
                sonde_depth_delta! = sonde_depth! - sonde_depth_last! // Localy used variable.
                IFF (sonde_depth_delta! <= DELTA_D_MIN! ) // Compare the change in depth over the last DELTA_CLICKS to our threshold.
                    temp_STR$ = "Winch flt or btm strike on click " + STR(clicks_last_delta) + "/" + STR(clicks_desired) + "@" + STR(sonde_depth!) + "m. Only " + STR(sonde_depth_delta!) + " m travel in last " + STR(DELTA_CLICKS) + " clicks."
                    IF (sonde_depth_delta! < -0.1 ) sms_msg$ = sms_msg$ + temp_STR$
                    STORE msg_pointer, "ERROR: ", temp_STR$: GOSUB LogMessage
                    GOSUB MotorOff // We are in the water and something is wrong.
                    check_WL = 0 : check_cond = 0 : RETURN // Turn off Conductivity check
                ELSE // All is well.
                    STORE msg_pointer, "On click ",clicks_last_delta,"at ",#6.3F,sonde_depth!," delta D:",#5.3F,sonde_depth_delta!," > ",DELTA_D_MIN! : GOSUB LogMessage // This is stored  every DELTA_CLICKS
                    //IF deBug PRINT "Delta D:",#5.3F,sonde_depth_delta!," > ",DELTA_D_MIN!// This is printed every DELTA_CLICKS
                    sonde_depth_last! = sonde_depth! // Set the last sonde depth to the current sonde depth for next time.
                ENDIF
            ENDIF
            IFF TSerByteAvail(SONDE_IN_PORT) >= DATA_BUFFER  //If there is any sonde data on the buffer, there are a few things to do and check...
                IFF sonde_logging = 'T'    // Do we want to log it?
                    GOSUB LogSondeData   // Get a line of buffered data and STORE() it
                    // Launch check is a routine which early in the cast makes sure everything is going well. RYAN: May be redundant now that we have back wind detection.
                    IF clicks_counted >= (LAUNCH_CHECK_CLICKS - 2)  & clicks_counted <= (LAUNCH_CHECK_CLICKS + 2) GOSUB LaunchCheck
                ENDIF
                GOSUB GetSondeDepth  // returns sonde_depth! variable
                IFF sonde_depth! >= depth_target! & motor_running = 'D' // Turn the motor off if we've reached our depth or conductivity conditions
                    IFF check_cond = 1
                        IFF (sonde_depth! > (SONDE_WL_MIN! ) & sonde_conduct! > saltwater_cond! )
                            STORE msg_pointer, "",cast_mode,"Reached WL ",#6.3F,sonde_depth!," m > ",#6.3F, SONDE_WL_MIN!," m and cond. ", #6.3F, sonde_conduct!, " > ", #6.3F, saltwater_cond!, " on descent."
                            GOSUB LogMessage
                            GOSUB MotorOff
                            check_cond = 0 : RETURN // Turn off Conductivity & waterline checks
                        ENDIF
                    ELSE
                        STORE msg_pointer,  "",cast_mode,"Depth of ",#6.3F,sonde_depth!, " m, >= target (",depth_target!," m) on descent.": GOSUB LogMessage
                        GOSUB MotorOff // Going down and ...
                        RETURN
                    ENDIF
                ENDIF
                IFF motor_running = 'U'// going up.
                    IFF check_cond = 1 // Sometimes we want to monitor conductivity and stop if the conductivity sensor changes state
                        IFF (sonde_depth! < SONDE_WL_MAX! & sonde_conduct! <= saltwater_cond!)
                            STORE msg_pointer, "",cast_mode,"Reached WL ",#6.3F,sonde_depth!,"m < ",#6.3F,SONDE_WL_MAX!," m and cond. ",#6.3F,sonde_conduct!," <= ",#6.3F,saltwater_cond!," on retrieval."
                            GOSUB LogMessage
                            GOSUB MotorOff
                            check_WL = 0 : check_cond = 0 : RETURN // Turn off Conductivity check
                        ENDIF
                    ELSE
                        IFF sonde_depth! <= depth_target!
                            STORE msg_pointer,  "",cast_mode,"Depth ",#6.3F,sonde_depth! ," m <= target ", depth_target!," m on retrieval.": GOSUB LogMessage
                            GOSUB MotorOff
                            check_WL = 0 : check_cond = 0 : RETURN // Turn off Conductivity check
                        ENDIF
                    ENDIF
                ENDIF
            ENDIF
            IF check_WL GOSUB WaterLineDock // Sometimes we want to check if the sonde is approaching the waterline
        WEND
    ELSE
        PRINT clicks_desired," clicks not valid."
    ENDIF
    RETURN

PingerOff:
    PCLR 3 // Turn off depth sounder
    TSerInFlush(DEPTH_PORT) // Flush port
    RETURN

PingerOn:
    PSET 3       // Set pin 3 high
    RETURN

MotorWatcher:  // Reads clicks_counted, encoder_cycles, temp_clicks, ENCODER_CYCLES_MAX, current_idle!,
    //             AMPS_BOOSTED!, AMPS_NORMAL!, AMPS_LOW!, boost_current, BOOST_COUNT, max_current_load!,
    //             sonde_conduct!, sonde_depth!, SONDE_WL_MIN, SONDE_WL_MAX, MOTOR_FUSE!, INRUSH_CLICKS and cast_mode!
    // Increments encoder_cycles every time through. Resets to 0 when we see a click.
    // clicks_counted is incremented by the COUNT command which should be much more reliable.
    // Watches for motor amps exceeding max_current_load. Sets high_current to 'T' if they do.
    // Modifys max_current_load with this scheme:
    //   Low current when we are out of the water.
    //   Boost current if signaled until BOOST_COUNT clicks
    //   Normal current if we are out of the water (sonde_conduct)
    //   Note that currents can be lowered in other routines such as MotorUp
    //   until the state changes then the incrementing resets. This allows us to
    //   count the number of times we've seen a state and know what the previous
    //   state was.
    //   If temp_clicks is set, this will restore clicks_counted after two clicks
    // motor_running <> 'F' while motor is running and should be monitored for motor shutdown
    // See if it is time to modify maximum current
    // Check for any boost requests
    IFF boost_current = 'T' // If we are boosting current
        IF (sonde_conduct! < saltwater_cond!)  max_current_load! = AMPS_BOOSTED! // If we are in the water set alarm current to boost levels
        IFF max_current_load! > AMPS_NORMAL! // Return current to normal level if our current is boosted and...
            IF clicks_counted + temp_clicks >= BOOST_COUNT  max_current_load! = AMPS_NORMAL! // We have reached our boost count
            IF sonde_conduct! < saltwater_cond! max_current_load! = AMPS_NORMAL! // We are out of the water (is this line pointless?)
            boost_current = 'F' // reset flag
        ENDIF
    ENDIF
    current_load! = (CHAN(7) * CURRENT_MULIPLIER) - current_idle! // See what the motor current is
    voltage_load! = CHAN(6) : voltage_load! = (CHAN(6)/4369.0) + 1.7 // Charge up a/d from voltage divider then record actual voltage
    IFF motor_running = 'U' // See if we should go to low current mode while raising. Are we out of the water?
        IFF(sonde_depth! < SONDE_WL_MAX!) // If so, see if we can lower max_current_load to soften landing
            IF max_current_load! > AMPS_NORMAL!  max_current_load! = AMPS_NORMAL! : boost_current = 'F' // return to normal mode if boosted
            IF (current_load! * 1.1 < AMPS_LOW!) & (AVP_LIMIT_RELAY = 0) max_current_load! = AMPS_LOW!  // but make sure this won't instantly stop motor and don't use on new motorboard.
        ENDIF
    ENDIF
    // Now check all the conditions that will cause the motor to turn off due to high amps
    IFF current_load! > max_current_load! // Our current is above normal
        IFF current_load! > MOTOR_FUSE! // and above the absolute maximum it should ever be (includes inrush)
            GOSUB MotorOff
            IF deBug PRINT
            STORE msg_pointer, "",cast_mode,"ERROR: VERY HIGH current of ", #6.3F, current_load!, " A > (",#6.3F,MOTOR_FUSE!," A) on click ", #1D, clicks_counted, "(",#1D, ABS(encoder_cycles), ")!" : GOSUB LogMessage
            high_current = 'T'
            RETURN
        ENDIF
        IFF (clicks_counted >= INRUSH_CLICKS) // above current maximum (does not include inrush)
            GOSUB MotorOff
            IF deBug PRINT
            STORE msg_pointer, "",cast_mode,"ERROR: HIGH current of ", #6.3F, current_load!, " A > (",#6.3F,max_current_load!, " A) on click ", #1D, clicks_counted, "(st ",#1D, ABS(encoder_cycles), ")!" : GOSUB LogMessage
            high_current = 'T'
            RETURN
        ENDIF
    ENDIF // Done checking for High Current conditions
    IF current_load! < PTC_CURRENT_MAX! GOSUB LowCurrent // The current is too low. Why? This will probably turn the motor off unless there's no relay on the system
    encoder_cycles = encoder_cycles + 1 // This just keeps track of how many times we've been through here between clicks.
    // This uses the "COUNT clicks_counted" command.
    IFF clicks_counted > clicks_last_counted    // We've had a click so update status
        StopWatchStart()
        IF deBug = 0 PRINT #2D,clicks_counted, " ",#6.3F, sonde_depth!, "\r";  // Abbreviated just to see that it's running.
        IF deBug PRINT #3D,clicks_counted, "/", #3D, clicks_desired," clicks, SndDpth:",#6.3F, sonde_depth!, ", Cond: ",#6.3F,sonde_conduct!," Chlor:",#5.1F, sonde_chlor!, ", ",#5.2F, current_load!, "/", max_current_load!,"A @ ",voltage_load!," V";
        IF deBug = 2 PRINT " Buf:",#3D,TSerByteAvail(SONDE_IN_PORT);
        IF deBug PRINT
        clicks_last_counted = clicks_counted
        encoder_cycles = 0 // Reset the state counter
    ENDIF
    // A few more checks
    IFF StopWatchTime() > ENCODER_MAX_TIME // This is now based on time, currently averaging 2000000
       // A timeout could be caused by the limit relay (if so equipped), the PTC tripping, winch error or broken line.
        STORE msg_pointer, "ERROR: ENCODER TIMEOUT ",StopWatchTime(), " > ", ENCODER_MAX_TIME : GOSUB LogMessage
        IFF current_load! <= PTC_CURRENT_MAX! // Low current indicated a PTC, limit switch, or electrical failure
            GOSUB LowCurrent // this should turn the motor off.
        ELSE // Normal current suggests a broken encoder, winch or lift line. (we've seen all three of these)
            GOSUB MotorOff
            STORE msg_pointer, "Normal current of ",#6.3F, current_load!," indicates a winch or encoder fault." : GOSUB LogMessage
        ENDIF
        //IF motor_running <> 'F' GOSUB MotorOff
        RETURN // Either way, motor is off, might as well skip the rest.
    ENDIF
    IF StopWatchTime() > ENCODER_MAX_TIME/2  GOSUB EncoderOn // We're halfway to a time out, make sure encoder is on
    // Sometimes we save a temporary click count. This is to maintain an overall clicks_counted yet allow for
    // inrush current.
    IFF temp_clicks > 0 & clicks_counted > INRUSH_CLICKS  // We stored a temporary click count & We should be safely past the inrush spike.
        clicks_counted = clicks_counted + temp_clicks // Now that we're past inrush, time to restore it...
        temp_clicks = 0 // and reset the temporary variable
    ENDIF
    RETURN //----------------------END MotorWatcher---------------------------------------

LowCurrent: // Low current can be caused by a number of things: Limit Relay tripped, PTC tripped, Motor failure, PTC failure.
    HPSleep(0) : HPSleep(10) // Give it a little time....
    current_load! = (CHAN(7) * CURRENT_MULIPLIER) - current_idle! // See what the motor current is
    IFF current_load! > PTC_CURRENT_MIN! & current_load! < PTC_CURRENT_MAX! // We are between PTC_CURRENT_MIN and PTC_CURRENT_MAX, so the PTC has probably tripped.
        STORE msg_pointer, "",cast_mode$,"Probable PTC trip! (",#6.3F,current_load!,"A)" : GOSUB LogMessage
        GOSUB MotorOff
        HPSleep(0) // If it is a PTC trip we will want to wait a few seconds to let the PTC cool down
    ENDIF
    IFF current_load! <= PTC_CURRENT_MIN!  // This is where we will end up if we have an external relay which has stopped the motor. A hardware fault might also get us here.
        IFF AVP_LIMIT_RELAY = 1 // Only do this if we have a limit switch and relay (and aren't in a recursive loop)
            AVP_LIMIT_RELAY = 2 // Only temporary, this will prevent recursion!
            clicks_desired = 0
            IFF motor_running = 'U' // We were raising (this is expected)
                STORE msg_pointer, "Limit Switch Trip @ ",#5.3F, sonde_depth!," (",#6.3F,current_load!,"A)" : GOSUB LogMessage
                clicks_desired = 5 // lower one click
            ENDIF
            IFF motor_running = 'D' & clicks_counted > 5 // We were lowering! Backwind
                GOSUB ClearSched        // Set all SYNC_TIME() entries to 99.
                temp_STR$ = "Backwind, limit switch tripped while lowering. Schedule Cleared. "
                STORE msg_pointer, "FATAL ERROR: ",temp_STR$ : GOSUB LogMessage
                sms_msg$ = sms_msg$ + temp_STR$ + "MUST LOGIN TO RESUME." // this will send SMS message at end of cast
                clicks_desired = 0 // Don't move, you'll just mess it up more.
                cast_status = 0 // Signals cast is to be aborted.
            ENDIF
            GOSUB MotorOff
            GOSUB EncoderOff // Turning off the encoder re-enables the motor. Clever hardware!
            // Caution! This call to MotorRun is recursive, as we are currently in MotorRun --> MotorWatcher.
            // By manipulating the AVP_LIMIT_RELAY variable, we can keep the recursion to a single level.
            IF clicks_desired <> 0 & LEFT(cast_mode$,4) <> "Cons" GOSUB MotorRun // The encoder is off, but it will be turned on halfway to a timeout.
            AVP_LIMIT_RELAY = 1 // Now that we've prevented recursion, re-set variable back to normal
        ELSE  // The current is too low to be a PTC, which leaves an electical fault as the likely problem. This will stop on a clicks timeout?
            STORE msg_pointer, "Very low current (", #6.3F,current_load!," A) - ",AVP_LIMIT_RELAY : GOSUB LogMessage
            IFF AVP_LIMIT_RELAY = 0
                PRINT "ERROR: Probable electrical fault."
            ELSE
                AVP_LIMIT_RELAY = 1 // We were getting an infinite loop
            ENDIF
        ENDIF
    ENDIF
    IF motor_running = 'F' HPSleep(300) // The sleep should only do anything if it was a PTC trip.
    RETURN

ReHome: // This routine attemps to get the sonde from any position, back to
    // it's startup position. It is usually called when the sonde is in an
    // unexpected position. The sonde is assumed to be sampling.
    // First determine if we want to try lowering the sonde a bit first
    GOSUB EncoderOn         // Turn on Optical Encoder just to be sure
    //sonde_depth! = 0     // Clear the current depth to make sure we get a new value.
    GOSUB GetSondeDepth
    clicks_desired = STARTUP_CLICKS // Lower STARTUP_CLICKS clicks to prevent jams
    depth_target! = 9999 // We don't want it stopping due to depth
    GOSUB MotorRun // Now run this motor command based on clicks_desired
    // Next step is to raise until we get an overcurrent. Watch for waterline and slow down when encountered.
    // Re-Home to make sure sonde is where we expect it to be
    IFF high_current <> 'T' // Don't raise if the previous operation resulted in a high current.
        HPSleep(0) : HPSleep(100) // Need to sleep between motor direction changes
        clicks_desired = -999  // UP all the way
        depth_target! = -9999 // We don't want it stopping due to depth
        check_WL = 1 // check for the waterline on the way up
        GOSUB MotorRun // 1000 clicks_desired is just to stop motor if cable has broken...
        STORE msg_pointer, "",cast_mode," Raised ", clicks_counted, " clicks." : GOSUB LogMessage
    ELSE
        STORE msg_pointer, "Previous re-home operation resulted in current alarm, Raising operation canceled." : GOSUB LogMessage
    ENDIF
    // The sonde should now be hard up against the lifting block, or well jammed somewhere else.
    // Lowering a little will either put us in our HOME_POSITION or reduce the chance of blowing the main fuse.
    HPSleep(0) : HPSleep(100) // Sleeping between motor state changes allows current readings to settle
    clicks_desired = HOME_POSITION //DOWN
    depth_target! = 9999 // We don't want it stopping due to depth
    GOSUB MotorRun
    STORE msg_pointer, "",cast_mode," Lowered ", clicks_counted, " of ", HOME_POSITION, " clicks to HOME position. ",cast_mode," COMPLETE." : GOSUB LogMessage
    RETURN //----------------------END ReHome---------------------------------------

WaterLineDock:
    // This subroutine is used to slow the RETRIEVAL of the sonde when it reaches the waterline. This is needed since
    //    there is an averaging delay in the data. Slowing the sonde allows the data to more accurately reflect the sonde's status.
    // Lower bound is SONDE_WL_MAX! and upper bound is SONDE_WL_MIN! which is about a 5cm band
    IFF (sonde_depth! <= SONDE_WL_MAX!) // These two comparisons are nested for speed.
        IFF (sonde_depth! >= SONDE_WL_MIN!) & sonde_conduct! > saltwater_cond! & motor_running <> 'F' & clicks_counted >= INRUSH_CLICKS
            IF INSTR(cast_mode$,"WL") = 0 cast_mode$ = cast_mode$ + "(WL) " // Used to prepend motor messages
            // Stop until there is data on the buffer or we timeout, then raise for a second
            IF deBug PRINT "Slow retrieval "
            IFF motor_running <> 'F' // Stop the motor from raising
                temp_clicks = clicks_counted // store the current clicks_counted until we restart the motor
                GOSUB MotorOff // turn off motor
                HPSleep(0) : HPSleep(200)  // Sleep for two seconds
                TSerInFlush(SONDE_IN_PORT) // Flush out anything in the port
            ENDIF
            i = 0 // i is used as a 10 sec escape if we can't get the sonde_depth
            WHILE TSerByteAvail(SONDE_IN_PORT) < DATA_BUFFER & i < 50 // then wait for it to re-fill. i is for escape
                HPSleep(0) : HPSleep(20)
                i = i + 1
            WEND
            IF TSerByteAvail(SONDE_IN_PORT) >= DATA_BUFFER GOSUB GetSondeDepth // Monitor depth and conductivity if there is a reading
            IFF motor_running = 'F'
                // Turn motor back on. It should run for at least two clicks before pausing again if necessary.
                IF clicks_desired < 0 GOSUB MotorUp // this clears clicks_counted, but temp_clicks will restore it after two clicks
                IF clicks_desired > 0 GOSUB MotorDown // this clears clicks_counted, but temp_clicks will restore it after two clicks
            ENDIF
        ENDIF
    ENDIF
    RETURN
//------- End Digital I/O and Motor routines:-----------------------------------
//------------------------------------------------------------------------------
//       Depth Related routines
//          InitializeDepth
//          GetDepth
//          CalculateDepthTarget
//          SortDepthIndex
//          ResetPingArray
//
InitializeDepth:
    IF DEPTH_PORT = 8 cast_mode$ = "Depth (SeaTalk):"
    IF DEPTH_PORT = 12 cast_mode$ = "Depth (NMEA):"
    sub_arg(0) = DEPTH_PORT
    sub_arg(1) = 1 // Low Priority
    sub_arg(2) = 0 // 0 = Input
    sub_arg(3) = DEPTH_BUFFER // Buffer
    sub_arg(4) = DEPTH_BAUD
    GOSUB OpenPort
    RETURN

GetDepth:    // Captures (DEPTH_SAMPLES_MAX) values between MIN_DEPTH_M and max_depth_m into ping_array().
    pings_good = 0         // LOCAL to hold number of good pings
    pings_bad = 0          // LOCAL to hold number of bad pings
    //temp_INT = 0           // LOCAL to hold temporary numeric values
    temp_byte_count = 0    // LOCAL to count bytes when parsing depth values
    temp_FLT! = 0.000      // LOCAL to hold one depth value in m
    fail_count = 0         // LOCAL to flag bad data
    GOSUB PingerOn         // Turn On Depth Sounder if it isn't already
    GOSUB ResetPingArray  // Clear the depth array
    // Need to wait three seconds for good data to start then flush input buffer
    HPSleep(0) : HPSleep (300)
    //TSerInFlush(DEPTH_PORT)     // Clear the contents of the port
    StopWatchStart()           // Begin timing until next char
    STORE msg_pointer, "",cast_mode, "Attempting to collect ", DEPTH_SAMPLES_MAX, " depth values" : GOSUB LogMessage
    // StopWatchtime is to escape if no data available, pings_bad is to escape on too many failed pings.
    GOSUB ResetWatchDogTimer    // Restart the watchdog timer
    WHILE (pings_good < DEPTH_SAMPLES_MAX) & (StopWatchTime() < DEPTH_TIMEOUT)  & (pings_bad < DEPTH_SAMPLES_MAX * 3)
        IFF DEPTH_PORT = 8 // it's a sea-talk port
            // Sea-Talk Data Format (in hexadecimal notation):
            //    00  02  IJ  XX YY
            //          Depth below transducer: (XX + 256* YY)/10 feet
            //          Display units: I=0 => feet, I=4 => meter
            //          Flags: J&1 Shallow Depth Alarm   (J=1)
            //                 J&4 Transducer defective (J=4)
            //    If data is unavailable for more than DEPTH_SYNC data gathering is aborted
            IFF TSerByteAvail(DEPTH_PORT) // See if there is data available
                temp_INT = TSerGetByte(DEPTH_PORT)       // Get a value from the depth port
                temp_byte_count = temp_byte_count + 1                // increment bytecount by one
                // PRINT #02H,temp_INT, "(",temp_byte_count, ") "
                IFF temp_byte_count = 3          // If this is the third in the sequence...
                    IFF temp_INT & 4         // See if it is an error bit and...
                        fail_count = 1          // Set Bad Data flag...
                        pings_bad = pings_bad + 1
                    ELSE
                        fail_count = 0          // Or not
                    ENDIF
                ENDIF
                IF temp_byte_count = 4 temp_FLT! = temp_INT    // Fourth bit is part of the value
                IF temp_byte_count = 5 temp_FLT! = temp_FLT! + temp_INT * 256  // We now have our value but in decimal feet.
                IF temp_byte_count > 5 temp_byte_count = 0     // Reset byte count if we have gone too far
                StopWatchStart() // reset StopWatchTime()
            ENDIF
            IFF StopWatchTime() > DEPTH_SYNC & temp_byte_count=5
                IFF fail_count = 0  // Only process data not marked as bad
                    temp_FLT! = temp_FLT! * 0.03048    // Convert from decimal feet to meters
                    // Now we have a value from the sounder. See if it is a good value
                    IFF temp_FLT! < max_depth_m! & temp_FLT! > MIN_DEPTH_M!   // Is this value between pre-defined limits?
                        pings_good = pings_good + 1        // increment the number of good pings
                        ping_array!(pings_good) = temp_FLT!  // Put the value into the array
                        IF deBug PRINT "ST sample ",#02D, pings_good," at ",#6.3F, temp_FLT!," m = ";
                        // convert to feet and print if deBug is on
                        IF deBug temp_FLT! = temp_FLT! * 3.28 : PRINT #6.3F, temp_FLT!, " feet              \r";
                    ELSE  // Value was too high or low
                        pings_bad = pings_bad + 1
                    ENDIF
                ENDIF
                temp_byte_count = 0
            ENDIF
        ENDIF
        IFF DEPTH_PORT = 12 // it's a NMEA 0138 source
            // NMEA 0138 Data Format (in ascii):
            //           1    3
            //           |    |
            //    $SDDPT,x.x,*hh<CR><LF>
            //    Field Number:
            //     1) Depth, meters
            //     3) Checksum
            IFF TSerByteAvail(DEPTH_PORT) // See if there is data available
                IFF TSerGetByte(DEPTH_PORT) = '$'                      // This is the first character of a NMEA data line
                    temp_FLT! = 0.000                     // depth in meters
                    command_str$ = "" // Needs to be cleared every loop
                    temp_STR$ = "A" // LOCAL
                    pointer_address = ConvertVarPtr(temp_STR$)
                    REPEAT
                        POKE pointer_address + 1, TSerGetByte(DEPTH_PORT)
                        command_str$ = command_str$ + temp_STR$
                        IF command_str$ = "SDDPT" temp_STR = "\n"  // Check to see which sentence we have after 5 characters. If it is SDDPT, abort loop. It's SDDBT that we want.
                    UNTIL temp_STR$ = "\n" | TSerByteAvail(DEPTH_PORT) <= 0
                    IFF LEFT(command_str$,5) = "SDDBT" & LEN(command_str) > 13
                        temp_FLT! = VAL(MID(command_str$,7,5))
                        temp_FLT! = temp_FLT! * 0.328 // extract the value, convert to m
                        IFF temp_FLT! > (MIN_DEPTH_M! / 2) & temp_FLT! < ( max_depth_m! * 1.5)   // Make sure it's not too shallow or deep
                            pings_good = pings_good + 1
                            ping_array!(pings_good) = temp_FLT! //put the value into the array
                            StopWatchStart() // Reset StopWatchTime() stopwatch
                        ELSE  // A zero depth is a bad ping.
                            pings_bad = pings_bad + 1
                        ENDIF
                        IF deBug PRINT "NMEA sample ",#2D, pings_good," at ",#5.3F, temp_FLT!," m = ";
                        IF deBug temp_FLT! = temp_FLT! * 3.28 : PRINT #5.3F, temp_FLT!, " feet              \r";     // convert to feet and print if deBug is on
                    ENDIF
                ENDIF
            ELSE
                HPSleep(0) : HPSleep(100)  // There is no character, so wait half a second (may need to wait longer)
            ENDIF
        ENDIF
    WEND
    IF deBug PRINT
    GOTO ProcessDepth // Not making this a GOSUB eliminates a single RETURN

ProcessDepth:
    // Calculate depth target based on values from pinger
    // RO variables: pings_good, cast_count, cast_mode, DEPTH_SAMPLES_MIN, DEPTH_PERCENTILE, MAX_TIDE_D, DEPTH_MARGIN_M, SONDE_CAGE_LEN
    // RW variables: depth_target_last, water_depth_m, ping_array(), max_depth_m
    // WO variables: depth_target, temp_FLT
    STORE msg_pointer, "Processing Depth:" : GOSUB LogMessage // All following messages can use AppendMessage
    IFF pings_good >= DEPTH_SAMPLES_MIN // We have enough pings to work with
        GOSUB SortDepthIndex
        // Here we check to see that there hasn't been a drastic change in depth since the last
        // cast. If there has been, we are probably bouncing off of a Pycnocline or have a bad depth return.
        // The criteria is a pinger depth change of more than MAX_TIDE_D m from the last water_depth_m.
        // A difference greater than 0.300 m is probably a false return. Obviously there is no sense
        // doing this on the first cast.
        temp_FLT! = ping_array(INT(pings_good * DEPTH_PERCENTILE!)) // Get 90th percentile. E.g. the 54th sample out of 60
        IFF cast_count > 1  // Don't do this on the first cast
            IFF ABS(temp_FLT! - water_depth_m!) >= MAX_TIDE_D!
                IFF (temp_FLT! > water_depth_m!) // Deeper than expected.
                    STORE msg_pointer, "",cast_mode$,"NOTE: Abnormal increase of ",#6.3F,(temp_FLT! - water_depth_m!)," m > ",#6.3F,MAX_TIDE_D!, " m threshold. Possible sounder error.": GOSUB AppendMessage
                    temp_FLT! = water_depth_m! + MAX_TIDE_D!  // Increase water depth by MAX_TIDE_D! to account for tidal changes!
                ELSE // Shallower than expected
                    STORE msg_pointer, "",cast_mode$,"NOTE: Abnormal reduction of ",#6.3F,(temp_FLT! - water_depth_m!)," m > ",#6.3F,MAX_TIDE_D!, " m threshold. Possible pycnocline return.": GOSUB AppendMessage
                    temp_FLT! = water_depth_m! - MAX_TIDE_D!   // Reduce water depth by MAX_TIDE_D! to account for tidal changes
                ENDIF
            ENDIF
        ENDIF
        IFF  water_depth_m! <> temp_FLT! // Now set the new depth.
            STORE msg_pointer, "",cast_mode$,"Altering water depth from ", #6.3F, water_depth_m!, " m. to: ",#6.3F, temp_FLT!, " m." : GOSUB AppendMessage
            water_depth_m! = temp_FLT!
        ENDIF
        GOSUB CalculateDepthTarget // returns depth_target!
        IFF max_depth_m! - water_depth_m! <= 0.100  // Are we in a storm surge condition????
            temp_FLT! = max_depth_m!
            max_depth_m! = water_depth_m! + 0.250
            STORE msg_pointer, "",cast_mode$,"NOTE: Depth near max threshold, increasing max_depth_m from ",#6.3F, temp_FLT!, " m to ", max_depth_m!, " m." : GOSUB AppendMessage
        ENDIF
    ELSE // We got less than required samples (perhaps none), so leave depth_target alone.
        depth_target! = depth_target_last!
        IF depth_target! = 0.0 GOSUB CalculateDepthTarget // If we've never had any pings or a calculated depth, use the default depth_target values.
        IFF pings_good = 0 // No data
            STORE msg_pointer, "",cast_mode$,"ERROR: No pings received. Using depth, cast values of ", #5.3F, water_depth_m!, " m and ",depth_target!," m" : GOSUB AppendMessage
        ELSE
            STORE msg_pointer, "",cast_mode$,"ERROR: Pinger timeout. ", pings_good, " of ", DEPTH_SAMPLES_MAX, " good and ", pings_bad, " bad values" : GOSUB AppendMessage
            STORE msg_pointer, "",cast_mode$,"Depth remains at: ",#6.3F, water_depth_m!, " m and target at ", depth_target! : GOSUB AppendMessage
        ENDIF
        IF deBug PRINT "Waiting for wipe."
    ENDIF
    HPSleep(6000)  // wait for wipe to finish (HPSleep(0) given previously)
    STORE msg_pointer, "",cast_mode$,"Depth is ", #5.3F, water_depth_m!," m, Target to ", depth_target!," m from ",depth_target_last!," m" : GOSUB LogMessage
    depth_target_last! = depth_target!
    RETURN
//------- End GetDepth subroutine----------------------------------------------

CalculateDepthTarget:
    depth_target! = water_depth_m! - DEPTH_MARGIN_M!// - SONDE_CAGE_LEN!
    IFF depth_target! > MAX_CAST_DEPTH_M!
        // This is deeper than we can go with our current equipment.
        STORE msg_pointer, "",cast_mode$,"NOTE: Cable too short to cast ", #6.3F,depth_target!," m. Depth target will be ", #6.3F, MAX_CAST_DEPTH_M!, " m." : GOSUB AppendMessage
        depth_target! = MAX_CAST_DEPTH_M! // This will override depth_target
    ENDIF
    IF (water_depth_m! < MIN_DEPTH_M!) sms_msg$ = sms_msg$ + "Pinged shallow depth of " + STR(water_depth_m!) +  " m." // Generate an SMS message for very shallow depths
    RETURN

//-----------------------------------------------------------------------------
//       SortDepthIndex
//          Uses insertion sort on ping_array() which contains pings_good records
SortDepthIndex:  // Uses local variables  i & j
    FOR i = 1 TO pings_good
        temp_FLT! = ping_array!(i)

        j = i - 1
        WHILE j >= 0 & ping_array!(j) > temp_FLT!
            ping_array!( j + 1 ) = ping_array!(j)

            j = j - 1
        WEND
        ping_array!( j + 1 ) = temp_FLT!
    NEXT i
    STORE msg_pointer, "", pings_good, " Sorted values: " : GOSUB BasicMessage
    FOR i = 1 to pings_good
        STORE msg_pointer, "",#5.3F, ping_array!(i), " ";
        IF i % 18 = 0 STORE msg_pointer, " " : GOSUB BasicMessage // Start a new line every 18 depths to keep the line from getting too long
    NEXT i
    STORE msg_pointer, " " : GOSUB BasicMessage // Finish off the line
    RETURN
//-----------------------------------------------------------------------------
//       ResetPingArray
//          Set all DEPTH_SAMPLES_MAX ping_array() values to 0.0
ResetPingArray:  // Uses local variable i
    FOR i = 0 TO DEPTH_SAMPLES_MAX
        ping_array!(i) = 0.000
    NEXT i
    RETURN
//------- End Depth Related Routines:-----------------------------------
//------------------------------------------------------------------------------
//       Wind Related routines
//          InitializeWind
//          GetWindData
//          ParseWindData
//          FinishWind
//          SetDataWind
InitializeWind:
    // The number of bytes in our serial input buffer (WIND_IN_BUFFER) is important. If this
    // number is too small, our buffer will overflow during a flash save.
    // If it is too big, there will not be enough resources to open
    // the other serial ports for input. OUTPUT opened at low priority and INPUT at high
    cast_mode$ = "Wind: "
    sub_arg(4) = 9600 // Baud Rate
    // Output
    sub_arg(0) = WIND_OUT_PORT
    sub_arg(1) = 1 // Low Priority
    sub_arg(2) = 1 // 1 = Output
    sub_arg(3) = 128 // Buffer
    GOSUB OpenPort
    // Input
    sub_arg(0) = WIND_IN_PORT
    sub_arg(1) = 3 // High Priority
    sub_arg(2) = 0 // 0 = Input
    sub_arg(3) = WIND_IN_BUFFER
    GOSUB OpenPort
    // Make sure we are sampling at 2Hz
    GOSUB SetDataWind
    data_send_str$ = "\x1B\x1B\x1B" : GOSUB DataSend  // Three escapes to get to menu
    data_send_str$ = "rbx" : GOSUB DataSend // r=rate, b=2Hz, x=return to sampling
    STORE msg_pointer, "Wind sampling at 2Hz" : GOSUB LogMessage
    RETURN

GetWindData:
    // Gets data from the WIND_IN_PORT and calls ParseWindData which stores a running average of wind values.
    // Uses GLOBAL variables: current_load!, pointer_address, wind_samples, WIND_SAMPLE_MAX,
    // Should not be called when motor is running.
    IFF motor_running = 'F'  // Since the motor isn't running we have plenty of time
        IF wind_samples = 0 wind_north! = 0.0 : wind_east! = 0.0 : wind_compass! = 0.0 : wind_velocity! = 0.0 : wind_direction! = 0 // Reset at beginning of each new sampling
        IFF TSerByteAvail(WIND_IN_PORT) >= 80 // Make sure we have at least one line of data
            IF (TSerByteAvail(WIND_IN_PORT) >= WIND_IN_BUFFER)   STORE msg_pointer, "ERROR: Wind Buffer Full" : GOSUB LogMessage
            IF deBug PRINT "Parsing Wind Buffer...";
            // Motor is stopped so get everything except the last partial word
            REPEAT  // We know there are at least 80 characters to parse
                command_str$ = ""
                temp_STR$ = "A" // LOCALy used
                pointer_address = ConvertVarPtr(temp_STR$)
                // As long as there is a full word int the wind buffer, get it
                REPEAT // build command_str$ until a CR
                    POKE pointer_address + 1, TSerGetByte(WIND_IN_PORT)
                    command_str$ = command_str$ + temp_STR$ // Ignore New Line (Hex10)
                UNTIL temp_STR$ = "\r" | TSerByteAvail(WIND_IN_PORT) <= 0
                GOSUB ParseWindData   // now that we have reached a CR, parse this string
            UNTIL ( TSerByteAvail(WIND_IN_PORT) < 40 & RIGHT(command_str,1) = "\r" ) | TSerByteAvail(WIND_IN_PORT) <= 0 | wind_samples > WIND_SAMPLE_MAX
            IF deBug PRINT "Done."
            // We want to get everything to the last CR but not including partial lines.
        ENDIF
    // ELSE the motor is running so we shouldn't be getting wind data!
    ENDIF
    RETURN

ParseWindData:
    // Expects command_str$ with a line of data
    // and increments wind_north!, wind_east!, wind_compass!, and wind_samples
    wind_speed_sample = 0        // LOCAL to hold single wind Speed sample
    wind_direction_sample = 0        // LOCAL to hold single wind Speed sample
    compass_sample = 0        // LOCAL to hold single compass direction sample
    IFF LEN(command_str$) = WIND_WORD_LEN // we have a full word
        wind_samples = wind_samples + 1 // Increment sample counter
        temp_INT = LEN(command_str)  // get length of string
        compass_sample = VAL(MID(command_str$,temp_INT - 9, 4))
        // The following two can sometimes have their offset changed
        wind_direction_sample = VAL(MID(command_str$, 7, 4))
        wind_speed_sample = VAL(MID(command_str$, 2, 4))  // Now extract velocity
        // Get direction... then get NS and EW velocity factors.
        // convert the speed to m/10s and componentise
        temp_FLT! = FLOAT(wind_speed_sample) * 0.04903 * COS(FLOAT(wind_direction_sample)/10)
        wind_north! = wind_north! + temp_FLT!
        temp_FLT! = FLOAT(wind_speed_sample) * 0.04903 * SIN(FLOAT(wind_direction_sample)/10)
        wind_east!  = wind_east! + temp_FLT!
        IF (compass_sample - wind_compass!/wind_samples  >  1800) compass_sample = compass_sample - 3600  // Handle 360 deg wraparound
        IF (compass_sample - wind_compass!/wind_samples  < -1800) compass_sample = compass_sample + 3600  //
        wind_compass! = wind_compass! + FLOAT(compass_sample)
    ELSE
        PRINT LEN(command_str$), " ";
    ENDIF
    command_str$ = "" // These characters have been parsed and are no longer needed.
    RETURN

FinishWind: // Closes and flushes the wind port, calculates the wind values, and writes the report to the CF card
    // Perform calculations
    // Average wind velocity is wind_velocity/wind_samples but componentized:
    IFF wind_samples > 0
        wind_north! = wind_north!/wind_samples
        wind_east! = wind_east!/wind_samples
        wind_velocity! = SQR(wind_north! * wind_north! + wind_east! * wind_east!)
        wind_direction! = ATN(wind_east!/wind_north!)
        IF ( wind_north! > 0 & wind_east < 0 )  wind_direction = wind_direction + 360
        IF ( wind_north! < 0 )  wind_direction = wind_direction + 180
        wind_compass! = wind_compass!/(10.0 * wind_samples)
        IF wind_compass! < 0 wind_compass! = wind_compass! + 360.0
        IF wind_compass! > 360 wind_compass! = wind_compass! - 360.0
        data_file_ptr = DATA_PTR_BEGIN - 100 + 23 // This should point us to a location just after the time stamp.
        // Write log data to memory
        // format and write the date and wind data to the data_file (before we call RTIME again)
        STORE data_file_ptr, "", #7.3F, wind_velocity!;
        STORE data_file_ptr, " ", #4.0F, wind_direction!, " ", #4.0F, wind_compass!;
        STORE data_file_ptr, " ", #7.3F, wind_north!, " ", #7.3F, wind_east!;
        STORE data_file_ptr, " ", #7, wind_samples
        STORE msg_pointer, "Wind: Stored ", wind_samples, " samples to memory." : GOSUB LogMessage
        STORE msg_pointer, "      Velocity:",  #7.3F, wind_velocity!, "m/s (",#5.1F, wind_velocity! * 1.94," knots), Direction:",#05.1F, wind_direction!;
        STORE msg_pointer, " Compass:",#05.1F, wind_compass!, " North:",#7.3F, wind_north!, " East:",#7.3F, wind_east!
        GOSUB AppendMessage
        //ALSO NEED TIME FROM FIRST SAMPLE TO LAST
        data_file$ = STR(todays_date) + ".wnd"
        IF todays_date > 20500000 data_file$="default.wnd" // we haven't set the date correctly
        temp_INT = CFSave(data_file$, data_file_ptr - DATA_PTR_BEGIN + 100, DATA_PTR_BEGIN - 100, 1) // write memory to the CF card
        IFF temp_INT < 1
            GOSUB GetCFerrorCodes // Get error code from temp_INT into temp_STR
            STORE msg_pointer, "Wind: Failed to write to file (", data_file$, ") ERROR: ",temp_STR, ". Writing to default.wnd." : GOSUB AppendMessage
            data_file$ = "default.wnd"
            temp_INT = CFSave(data_file$, data_file_ptr - DATA_PTR_BEGIN + 100, DATA_PTR_BEGIN - 100, 1)   //Write the file...
            IFF temp_INT < 1
                GOSUB GetCFerrorCodes // Get error code from temp_INT into temp_STR
                temp_STR$ = "Data save " + data_file$ + " fail(" + temp_STR$ + "). "
                sms_msg$ = sms_msg$ + temp_STR$ // this will send SMS message at end of cast
                STORE msg_pointer, "ERROR: ",temp_STR$ : GOSUB AppendMessage
            ENDIF
        ELSE
            STORE msg_pointer, "", cast_mode$, "Saved ", temp_INT, " of ", data_file_ptr - DATA_PTR_BEGIN + 100, " bytes to file ", data_file$, "." : GOSUB AppendMessage
        ENDIF
        data_file_ptr = DATA_PTR_BEGIN
        wind_samples  = 0       // reset numberof wind samples takes. The rest will be reset when GetWindData is first called during the next cast.
    ELSE // there is no data
        STORE msg_pointer, "", cast_mode$, "ERROR: No samples logged" : GOSUB LogMessage
    ENDIF
    RETURN

SetDataWind:
   data_in_port = WIND_IN_PORT
   data_out_port = WIND_OUT_PORT
    RETURN
//-------- End Wind Related Routines:-----------------------------------
//-------- Misc. Routines: ---------------------------------------------
//
//            OpenPort
//            Console
//            SubConsole
//            ConsoleHelp
//            GetDate
//            ReadSetupIni
//            CastCheck
//            LaunchCheck
//            ResetWatchDogTimer
//            GetCFerrorCodes
//            ErrorCheck
//            ClearSched
//            Stoppage
//            StopNow
OpenPort: // Opens a serial port based on sub_arg() Array
    // sub_arg(0) = Channel Number
    // sub_arg(1) = Priority(0-3)
    // sub_arg(2) = 0 for Input, 1 for Output
    // sub_arg(3) = Buffer (must be integral power of 2)
    // sub_arg(4) = Baud Rate
    STORE msg_pointer, "",cast_mode," Opening port ", sub_arg(0), " for ";
    IF sub_arg(2) = 0 STORE msg_pointer, "INPUT... ";
    IF sub_arg(2) = 1 STORE msg_pointer, "OUTPUT... ";
    // 11 works, 16 doesn't
    IF sub_arg(0) = 13 TPUUsendChan(11) // We cannot open the Usend default channel (13) with TSerOpen,
                                        //    so we reassign them to an unused channel.
    IF sub_arg(0) = 14 TPUUgetChan(15)  // We cannot open the Uget default channel (14) with TSerOpen,
                                        //    so we reassign them to an unused channel.
    STORE msg_pointer, "(pri=",sub_arg(1)," buf=",sub_arg(3)," baud=",sub_arg(4),")";
    IFF TSerOpen(sub_arg(0),sub_arg(1),sub_arg(2),0,sub_arg(3),sub_arg(4)) = 0 // Open the sonde port
        STORE msg_pointer, "",cast_mode," Success." : GOSUB LogMessage
    ELSE
        STORE msg_pointer, "",cast_mode," Failure." : GOSUB LogMessage
        STORE msg_pointer, "ERROR: port ", sub_arg(0), " failed to open." : GOSUB AppendMessage
    ENDIF
    RETURN

Console:  // Provides console access including access to sonde and wind consoles
    // There are two parts, the inned while loop builds the command string until a <CR> is seen. The string is then evaluated.
    PRINT "Welcome to console mode. Enter ? for help."
    WHILE (1) // Only exit on RETURN
        command_done = 'F'  //LOCAL to indicate status of command
        GOSUB GetDate  // this is the date which will be used for all log entrys while in console mode
        command_str$ = "" // LOCAL to hold user's command
        temp_STR$ = "A" // LOCAL to parse command
        pointer_address = ConvertVarPtr(temp_STR$) // Get our memory address
        start_time = ? // If no characters are entered for CONSOLE_TIMEOUT seconds, clear entered data and re-prompt
        cast_mode$ = "Console: "
        PRINT "Command:";
        WHILE INSTR(command_str$,"\r") = 0   // This Loop builds the command_str until CR or ctrl-X
             IFF KbHit()  // If there is a character from the keyboard
                key_pressed = KbChar() // key_pressed is the integer ascii code for character entered
                // Convert to lowercase.
                // key_pressed = key_pressed & &hDF // Actually converts to uppercase
                // There are certain characters we want to ignore if them come first
                IFF LEN(command_str$) = 0
                    IF (key_pressed = ' ' | key_pressed = 13 | key_pressed = 10 ) key_pressed = 0 // Ignore leading spaces, CR or LF
                ENDIF
                IFF key_pressed = 8  // it's a backspace so remove a character
                   command_str$ = LEFT(command_str$,LEN(command_str$)-1)
                   key_pressed = 0
                   PRINT "\rCommand:",command_str$," \b"; // re-print the command line
                   start_time = ?
                ENDIF
                IFF key_pressed = 24
                   command_str$ = "\x18\r" // send a ctrl-x and a CR
                   PRINT
                   command_done = 'T' : KbFlush() : RETURN
                ENDIF
                IFF key_pressed > 0
                   POKE pointer_address + 1, key_pressed  // now convert this dec to a str using poke
                   IFF LEN(command_str$) < command_str_MAX // Make sure that the string doesn't get too long
                      command_str$ = command_str$ + temp_STR$
                   ELSE    // This should never happen under normal circumstances
                      PRINT " <FLUSH>\r\nATE0"
                      SLEEP 0 : SLEEP 100 // We may be in some sort of feedback loop with the modem, so sleep a second then ...
                      KbFlush()           // flush the keyboard and try again.
                      command_str$ = "\r"
                   ENDIF
                   PRINT temp_STR$;  //echo character
                   start_time = ? // Escape
                ENDIF
                IFF ? - start_time > CONSOLE_TIMEOUT * 2000 // check for time out
                   key_pressed = 13
                   command_str = "\r"
                   PRINT " <TIME OUT>"
                   IF cast_count = 0 cast_status = 2   // If we timeout on the first cast, cast immediately
                ENDIF
             ENDIF
             IF ?(0) = 0 GOSUB ResetWatchDogTimer // reset watchdog timer every minute on the minute.
             GOSUB CastCheck  // If it is time to cast, don't get stuck here, but don't check before first cast
             IF (cast_status <> 0)  command_done = 'T' : KbFlush() : RETURN
        WEND
        PRINT
        // We should now have a command, but we should filter out things we don't want.
        IFF LEN(command_str$) > 1  // Not just a CR or LF
            // First the commands you don't want to log
            IF (INSTR(command_str$,"Syn") + INSTR(command_str$,"Command") + INSTR(command_str$,"RIN") + INSTR(command_str$,"+++") + INSTR(command_str$,"CARR")) > 0 PRINT "\r\nATE0" : command_done = 'E' // These generate an error
            IF LEFT(command_str$,1) = "?"      GOSUB ConsoleHelp : command_done = 'T'
            IF LEFT(command_str$,4) = "hell" | LEFT(command_str$,2) = "OK" command_done = 'T'   // The download script uses "hello" to get another Command: prompt and OK is sometimes returned by the modem.
            IF (command_done = 'F')  STORE msg_pointer, "Command: ",command_str : GOSUB BasicMessage // This excludes command_done = T or E
            // Now the commands we do want to log.
            IF LEFT(command_str$,8) = "quitprog" GOSUB Stoppage
            IF LEFT(command_str$,4) = "sini" command_done = 'T' : GOSUB InitializeSonde
            IF LEFT(command_str$,4) = "init" command_done = 'T' : GOSUB ReadSetupIni
            IF LEFT(command_str$,4) = "exit" command_done = 'T' : KbFlush() : RETURN // Go back to checking if it is time to cast.
            IF LEFT(command_str$,4) = "sond" command_done = 'T' : GOSUB SetDataSonde : GOSUB SubConsole
            IF LEFT(command_str$,4) = "park" command_done = 'T' : GOSUB ParkSonde
            IF LEFT(command_str$,4) = "samp" command_done = 'T' : GOSUB StartSondeSampling : PRINT "Done"
            IF LEFT(command_str$,4) = "sdat" command_done = 'T' : PRINT "Setting Date from Sonde..." : GOSUB SetDateFromSonde
            IF LEFT(command_str$,4) = "wind" command_done = 'T' : GOSUB SetDataWind : GOSUB SubConsole
            IF LEFT(command_str$,4) = "cast" command_done = 'T' : cast_status = 2 : KbFlush() : RETURN // Returns to The_Main_Loop where value of cast_status will initate a cast
            // Look for strings from modem to ignore. This is ugly, but saves code space.
                // sometimes the modems echoes "Syntax Error" back
                // sometimes the modems echoes "Command not understood"
                // Looking to ignore RING, NO CARRIER
                // Looking to ignore +++ modem escape
            IFF INSTR(command_str$,"CON") > 0 // As in "CONNECT"
                PRINT "------------ WELCOME ------------\r\nConnected to: ",SONDE_ID," at ", PROFILER_LOCATION$, "\r\n" : command_done = 'T' // When we get a CONNECT
                HPSleep(0) : HPSleep(25)
                KbFlush() // we should be able to flush the keyboard now
            ENDIF
            IFF LEFT(command_str$,2) = "up" | LEFT(command_str$,4) = "down"
                command_done = 'T'
                IFF INSTR(command_str,"e") > 0
                    command_str = LEFT(command_str, INSTR(command_str,"e") - 1) //Strip off the "!"
                    STORE msg_pointer, "Encoder turned off" : GOSUB LogMessage
                    GOSUB EncoderOff
                ELSE
                    GOSUB EncoderOn
                ENDIF
                IFF INSTR(command_str,"b") > 0
                    boost_current = 'T' // Boost the current
                    command_str = LEFT(command_str, INSTR(command_str,"b") - 1) //Strip off the "b"
                    STORE msg_pointer, "Max current boosted to ", #6.3F, AMPS_BOOSTED!, " A" : GOSUB LogMessage
                ENDIF
                // User wants to move sonde, get number of clicks
                IFF LEFT(command_str$,2) = "up"
                    clicks_desired = VAL(MID(command_str$,3,4))
                    clicks_desired = clicks_desired * -1 // Up (retrieval) is negative
                    depth_target! = -9999 // We don't want it stopping due to depth
                ELSE //IFF LEFT(command_str$,4) = "down"
                    clicks_desired = VAL(MID(command_str$,5,4))
                    depth_target! = 9999 // We don't want it stopping due to depth
                ENDIF
                GOSUB MotorRun
            ENDIF
            IFF LEFT(command_str$,4) = "skip"
                command_done = 'T'
                IF cast_count > 0 PRINT "Only first cast can be skipped!"
                IF cast_count = 0 STORE msg_pointer, "Skipping cast" : GOSUB LogMessage  : cast_count = 1
            ENDIF
            IFF LEFT(command_str$,4) = "reho"
                command_done = 'T'
                cast_mode$ = "Re-Home (user): "
                GOSUB ReHome
            ENDIF
            IFF LEFT(command_str$,4) = "dept"
                command_done = 'T'
                IF deBug = 0 PRINT "Setting deBug mode to 1": deBug = 1
                GOSUB GetDepth
            ENDIF
            IFF LEFT(command_str$,3) = "set" // Set Variable
                PRINT "Enter a variable name and a value. Case Sensitive.\r\nValue is overwritten on boot or init command.\r\nEnter ? as variable name for help."
                INPUT "Set:" current_variable$;
                INPUT "="  data_reply$
                IFF current_variable = "?"
                    CFExec("type var_help.txt")
                ELSE
                    GOSUB ParseVariables
                ENDIF
            ENDIF
            IFF LEFT(command_str$,4) = "tail" // expects "tail filename.xxx[:<number of bytes>]"
                command_done = 'T'
                temp_INT = INSTR(command_str$,":")
                IFF temp_INT > 0
                    byte_offset = VAL(MID(command_str$,temp_INT + 1,LEN(command_str$) - temp_INT))
                    command_str$ = LEFT(command_str$,temp_INT - 1) + "\r"
                ELSE
                    byte_offset = 80 * 100 // 100 lines of 80 characters is the default
                ENDIF
                temp_INT = LEN(command_str)
                data_file$ = MID(command_str$,6,temp_INT - 6) //strip off tail command
                GOSUB GetFileSize // Returns size of data_file as temp_INT
                byte_offset = temp_INT - byte_offset // set the offset.
                command_str$ = "xx " + STR(byte_offset) + ":" + data_file$
                GOSUB PartialDL  // Creates file partial.dat
                CFExec("type partial.dat")
            ENDIF
            // (x|y)s[ nnn:] (filename)
            IFF LEFT(command_str$,2) = "xs" | LEFT(command_str$,2) = "ys"
                command_done = 'T'
                command_str$ = LEFT(command_str,LEN(command_str$) - 1) // get rid of trailing CR
                IF INSTR(command_str$,":") > 0 GOSUB PartialDL
                // At this point, command_str will either be blank or xs|ys <filename>
                GOSUB ResetWatchDogTimer
                IFF command_str$ <> ""
                    PSET 2 // Turn off watchdog by leaving pin high.
                    //STORE msg_pointer, "Watch Dog will reboot system if ", LEFT(command_str$,1),"modem send of ", command_str$;
                    //STORE msg_pointer, " takes more than 20 minutes..." : GOSUB LogMessagend$,1),"modem send of ", command_str$;
                    STORE msg_pointer, "Watchdog off" : GOSUB LogMessage
                    temp_INT = CFExec(command_str$)
                    STORE msg_pointer, "Transfer completed. (",temp_INT,")" :  GOSUB LogMessage
                    GOSUB ResetWatchDogTimer
                    STORE msg_pointer, "Watchdog on" : GOSUB LogMessage
                ELSE
                    PRINT "File transfer error"
                ENDIF
            ENDIF
            IFF LEFT(command_str$,4) = "debu"
                command_done = 'T'
                deBug = deBug + 1
                IF deBug = 3 deBug = 0
                PRINT "De-Bug set to ", deBug, " (0 = Off, 1 = On, 2 = Verbose)"
            ENDIF
            IFF LEFT(command_str$,4) = "stat"
                command_done = 'T'
                voltage_idle! = CHAN(6) : voltage_idle! = (CHAN(6)/4369.0) + 1.7 // Charge up a/d from voltage divider then record actual voltage
                STORE msg_pointer, "Loc: ",PROFILER_LOCATION,  " AVP", PROFILER_NUMBER ," SN: ",SONDE_SN, ", ID: ",SONDE_ID : GOSUB LogMessage
                STORE msg_pointer, "Idle/Load Volts: ", #5.2F,voltage_idle!, "/",voltage_load!," V. Load Current: ",current_load!," A." : GOSUB BasicMessage
                STORE msg_pointer, "Cast times:";
                FOR i = 0 to 5
                    STORE msg_pointer, " ", SYNC_TIME(i);
                NEXT i
                STORE msg_pointer, "(99=disabled)" :  GOSUB BasicMessage
                STORE msg_pointer, "Cast startup ",LOOP_STARTUP_TIME," min." : GOSUB BasicMessage
                STORE msg_pointer, "Last cast #",#1D, cast_count," (",VGET(4)," total)." : GOSUB BasicMessage
                IF TSerByteAvail(SONDE_IN_PORT) >= DATA_BUFFER GOSUB GetSondeDepth  // get sonde_depth! if we are logging
                STORE msg_pointer, "Water depth: ",#5.3F,water_depth_m,"m, last cast target: ",depth_target_last!," m." : GOSUB BasicMessage
                STORE msg_pointer, "Sonde depth: ",#5.3F, sonde_depth!, "m Cond: ",#6.3F, sonde_conduct!, "mS/cm, Chlor:",#4.1F,sonde_chlor! : GOSUB BasicMessage
                STORE msg_pointer, "Wind:",#5.1F, wind_velocity! * 1.94," knots from ",#05.1F, wind_direction!, "deg.": GOSUB BasicMessage
                STORE msg_pointer, "Prog. Ver: ",VERSION$," Mod: ",FILE_MODIFIED, " deBug ",deBug, " EEPROM:",#8D, VGET(0) : GOSUB BasicMessage
            ENDIF
            // Now the ISCO commands: iscoread, iscostat, iscocast
            IFF LEFT(command_str,4) = "isco"
                IFF ISCO_ENABLED
                    ISCO_bottle = VGET(2)
                    command_str = RIGHT(command_str,LEN(command_str) - 4)
                    IFF LEFT(command_str,4) = "read"
                        command_done = 'T'
                        STORE msg_pointer, "Re-reading ISCO sched.." : GOSUB LogMessage
                        GOSUB ISCOscheduleRead
                    ENDIF
                    IFF LEFT(command_str,4) = "stat"
                        PRINT "Checking Isco Status..."
                        PRINT "Current bottle is ",ISCO_bottle,"."
                        // Report on the next cast
                        IFF ISCO_bottle >= 1 & ISCO_bottle <= ISCO_MAX_BOTTLES // Fixed: This was an OR but should be an AND
                            PRINT "The next ISCO cast is ",ISCO_sched(ISCO_bottle - 1,0);
                            PRINT " at ", ISCO_sched(ISCO_bottle - 1,1);
                            PRINT " to ",ISCO_sched(ISCO_bottle - 1,2), " cm" // Note that this is in cm rather than m
                        ELSE
                            PRINT "All bottles full"
                        ENDIF
                        command_done = 'T'
                    ENDIF
                    IFF LEFT(command_str,4) = "smpl"
                       command_str = RIGHT(command_str,LEN(command_str) - 4)
                       command_done = 'T'
                       STORE msg_pointer, "Entering manual cast mode for ISCO." : GOSUB LogMessage
                       STORE msg_pointer, "Current bottle number is ",ISCO_bottle : GOSUB AppendMessage
                       STORE msg_pointer, "Current sonde depth is ",#6.3F, sonde_depth!, " m" : GOSUB AppendMessage
                       cast_status = -2
                       GOSUB ISCOcast
                    ENDIF
                ELSE
                    PRINT "ISCO not enabled. Check ini file"
                    command_done = 'T'
                ENDIF
            ENDIF
            IFF command_done = 'F'   // Finally, look for picoDOS commands
                command_str$ = LEFT(command_str$,LEN(command_str) - 1)   //    remove trailing "\r"
                temp_INT = INSTR(command_str$," ") // find the first space and get command
                IF temp_INT > 0 temp_STR$ = LEFT(command_str$,temp_INT - 1) + "."  // append a "."
                IF temp_INT = 0 temp_STR$ = "." + command_str$ + "."
                IFF INSTR(PICO_COMMANDS$,temp_STR$) > 0 // see if command is in our list
                    command_done = 'T'  // We have a picoDOS command
                    STORE msg_pointer, "Sending to picoDOS: ",command_str! : GOSUB BasicMessage
                    temp_INT = CFExec(command_str$)
                    IF temp_INT = -1  PRINT "Success"
                    IF temp_INT = 0 PRINT "Failed"
                ENDIF
            ENDIF
            IFF command_done <> 'T'
                IFF command_done = 'F'
                    PRINT "Syntax error:",command_str$," not understood." // There was a problem with the command
                ELSE // It is 'E', probably garbage from the modem echoing.
                    PRINT "ATE0" // Turn modem echo off?
                    KbFlush()
                ENDIF
            ENDIF
        ENDIF
        GOSUB CastCheck // If it is time to cast, don't get stuck here
        IF (cast_status >= 1)  command_done = 'T' : KbFlush() : RETURN
    WEND
    RETURN

SubConsole: //Provides console access to sonde and wind instrument.
    // Expects data_in_port and data_out_port to be set
    // sends serial stream from console through to wind instrument
    // times out in three minutes of inactivity
    // control-x exits before time-out
    // control-b sends a true break
    temp_sleep_time = data_sleep_time // LOCAL to hold the original
    data_sleep_time = 1 // No sleeping reqired during console mode
    data_send_str = " " // String to be sent by DataSend subroutine
    temp_STR$ = "A"       // LOCAL to convert from numeric to ascii
    RTIME
    start_time = ?   // LOCAL to implement timeout
    // Flush the IO. We aren't interested in anything that was there before we entered console mode
    TSerInFlush(data_in_port) // clear the contents of the port
    TSerInFlush(data_out_port) // clear the contents of the port
    IFF data_in_port = WIND_IN_PORT
        PRINT "Starting wind console. Ctrl-x to exit ..."
        // First clear the output buffer and send three escapes
        data_send_str$ = "\x1B\x1B\x1B" : GOSUB DataSend  // Three escapes to get to menu
    ENDIF
    IFF data_in_port = SONDE_IN_PORT
        PRINT "Starting Sonde console. Press Ctrl-x to exit ..."
        //PRINT "   To turn on echo, type 'setecho 1' at # prompt."
        //PRINT "   press <CR> then type menu to get to menu."
        CtrlCHandle(0) // Disable ctrl-C while in sonde mode
    ENDIF
    REPEAT
        IF (TSerByteAvail(data_in_port) > 0)  GOSUB GetDataStr : PRINT data_reply;// If there's anything on the port Loop for long strings
        // the port is now empty
        IFF KbHit()  // something in on the keyboard input
            key_pressed = KbChar()
            start_time = ?    // Restart the stopwatch
        ELSE
            key_pressed = 0
        ENDIF
        // Now start looking for specific values
        IFF key_pressed = 24        // ctrl-x
            CtrlCReset()         // Clear any remaining ctrl-c
            CtrlCHandle(1)       // Re-enable ctrl-C
            //PRINT : PRINT "Returning to Main Console" : PRINT
            KbFlush()
            IFF data_in_port = SONDE_IN_PORT
                PRINT "Run sdate command if sonde's clock changed."
            ELSE
                data_send_str = "xxx" // Three x's to wind will get to OPERATE MODE
                GOSUB SetDataWind : GOSUB DataSend  // send this character
            ENDIF
            data_sleep_time  = temp_sleep_time // return to original value
            RETURN
        ENDIF
        IFF key_pressed > 2
            // Convert decimal number in key_pressed to ascii in temp_STR.
            // We can do this without parsing since key_pressed will only be a single character
            pointer_address = ConvertVarPtr(temp_STR$)
            POKE pointer_address + 1, key_pressed
            data_send_str = temp_STR : GOSUB DataSend  // send this character
            REPEAT  // Handle long strings. Do we need a break out?
                HPSleep(0) : HPSleep(10)  // Wait  a little for the reply
                GOSUB GetDataStr // get the reply (data_reply) while there are characters in the serial buffer
                IFF key_pressed = 8 // handle a keyboard backspace a little differently
                    PRINT "\b";
                ELSE
                    IF data_reply <> "\b" PRINT data_reply;  // print the reply if it is not a single backspace.
                ENDIF
                GOSUB CastCheck  // Make sure we exit when it's casting time
                IFF cast_status >= 1
                    PRINT
                    STORE msg_pointer,  "INIT: Exiting Console, time for cast at ",#02, ?(2), ":", ?(1), ":", ?(0) : GOSUB LogMessage
                    data_sleep_time  = temp_sleep_time // return to original value
                    KbFlush() : RETURN
                ENDIF
                key_pressed = 0
                data_reply = ""
                start_time = ?    // Restart the stopwatch
            UNTIL data_reply_full = 'T' | KbHit()
        ENDIF
        GOSUB CastCheck  // Make sure we exit when it's casting time
        IFF cast_status >= 1
            PRINT
            STORE msg_pointer,  "INIT: Exiting Console, time for cast at ",#02, ?(2), ":", ?(1), ":", ?(0) : GOSUB LogMessage
            data_sleep_time  = temp_sleep_time // return to original value
            RETURN
        ENDIF
    UNTIL ? - start_time > CONSOLE_TIMEOUT * 2000
    IFF data_in_port = WIND_IN_PORT
        data_send_str = "xxx" : GOSUB DataSend // Three x's to wind will get to OPERATE MODE
    ENDIF
    PRINT : STORE msg_pointer,  "CONSOLE: Timed out." : GOSUB LogMessage // message will be automatically time stamped.
    data_sleep_time  = temp_sleep_time // return to original value
    RETURN

ConsoleHelp:    // Print console help menu
    CFExec("type avp_help.txt")
    RETURN

PartialDL:// Expects command_str = <command> <offset>:<filename.xxx>
    // For a partial download, we read <offset> bytes of <filename.xxx> into memory
    // We than save this block of memory to partial.dat using CFSave.
    // If we are successful, we return command_str ready for a CFExec(comand_str)
    PRINT "Partial upload:",command_str$,"<"
    GOSUB ResetWatchDogTimer
    temp_INT = INSTR(command_str$," ")
    byte_offset = VAL(MID(command_str$, temp_INT + 1, INSTR(command_str$,":") - temp_INT - 1))
    data_file$ = RIGHT(command_str$,(LEN(command_str$) - INSTR(command_str$,":")))
    command_str$ = LEFT(command_str$, temp_INT) // save the xs or ys
    data_file_ptr = CFRead(data_file$,DFMAX,byte_offset,DATA_PTR_BEGIN) // Read this file into the data file, skipping the first byte_offset bytes
    IFF data_file_ptr > 0 // If we got anything...
       PRINT "Read ", data_file_ptr, " bytes of ", data_file$, " in to memory."
       data_file$ = "partial.dat" // Locally used
       // Now save it to data_file$, overwriting any previous data_file$
       temp_INT = CFSave(data_file$,data_file_ptr,DATA_PTR_BEGIN,0)
       IFF temp_INT >= 0
          PRINT "Saved ", temp_INT, " bytes from memory to ", data_file$,"."
          command_str$ = command_str$ + " " + data_file$ // This should be xs|ys data_file$
       ELSE
          GOSUB GetCFerrorCodes // Get error code from temp_INT into temp_STR
          PRINT "Failed to write ",byte_offset," bytes to file ",data_file$," for ",command_str$,". ERROR: ", temp_STR
          command_str$ = ""
       ENDIF
    ELSE // Nothing was read to memory
       temp_INT = data_file_ptr
       GOSUB GetCFerrorCodes // Get error code from temp_INT into temp_STR
       PRINT "Failed to read ",byte_offset," bytes from file ",data_file$," for ",command_str$,". ERROR: ", temp_STR
       command_str$ = ""
    ENDIF
    RETURN

GetFileSize:
    // Takes data_file$ and returns it's size as temp_INT
    msg_pointer = &H2C0000
    CFExec("dir " + data_file$ + " -m 2C0000 40") // DO a dir command and put the results in memory address 2c0000
    command_str$ = "A"
    pointer_address = ConvertVarPtr(command_str$) // Get our memory address
    msg_begin = msg_pointer
    REPEAT // This will transfer the results of the "dir" to command_str$
        temp_INT = PEEK(msg_begin) // temp_INT is now the ascii value of the sting
        POKE pointer_address + 1, temp_INT
        msg_begin = msg_begin + 1
        pointer_address = pointer_address + 1
    UNTIL temp_INT < 32 | temp_INT > 126
    msg_begin = msg_begin - msg_pointer //msg_begin is now the length of our string
    pointer_address = ConvertVarPtr(command_str$)
    POKE pointer_address,msg_begin - 1 // Need to set the length in the first bit.
    // The variable command_str should now be "<filename>     <filesize>"
    temp_INT = LEN(command_str$)
    data_send_str$ = RIGHT(command_str$,temp_INT - 12)
    temp_INT = 3 : GOSUB TrimStr // Do an AllTrim on data_send_str
    temp_INT = VAL(data_reply)
    IF deBug PRINT data_file$, " is ", temp_INT, " bytes"
    msg_pointer = MSG_STR_BEGIN // Reset the message pointer for the next message
    RETURN

GetDate: //Generates the date value used for filenames. Stores new values to EEPROM
    RTIME
    todays_date = 20000000 + (?(5) * 10000) + (?(4) * 100 ) + ?(3)
    IF todays_date = VGET(0) RETURN // No need to do anything
    IFF todays_date < FILE_MODIFIED | todays_date > (FILE_MODIFIED + 100000) // This gives us 10 years max after last FILE_MODIFIED date
        // Obviously invalid
        IF deBug PRINT "Internal date ", todays_date, " invalid. Will attempt to fix later."
        todays_date = FILE_MODIFIED  // Just in case it's not in EEPROM. This is slightly less wrong.
    ENDIF
    IFF todays_date > VGET(0) | todays_date > FILE_MODIFIED + 30 // The date is too big or too small.
        // It's a new day, so set some EEPROMs
        VSTORE 0,todays_date
        STORE msg_pointer,  "Date, ",todays_date, " stored to EEPROM(0).": GOSUB LogMessage
        temp_INT = VGET(3)   // This is yesterdays final cast_count
        VSTORE 3, cast_count // Store today's final cast count.
        IF temp_INT > cast_count temp_INT = cast_count // We had a reset so use our current cast_count.
        IF temp_INT < cast_count temp_INT = cast_count - temp_INT // No reset so use the difference (usually 48)
        temp_INT = VGET(4) + temp_INT // Increment the overall cast counter
        VSTORE 4, temp_INT // And store it.
        STORE msg_pointer,  "Total cast count is approx. ",VGET(4), " casts.": GOSUB LogMessage
        // Now let's do our daily voltage check.
        IF (voltage_load! < LOW_VOLTAGE! & current_load! < AMPS_NORMAL!) sms_msg$ = sms_msg$ + "Low Voltage: " + STR(voltage_load!) + "V @ " + STR(current_load!) + "A." // We have a low voltage situation
    ENDIF
    IFF todays_date < VGET(0) // We should set the date from EEPROM
        todays_date = VGET(0)
        IFF todays_date >= FILE_MODIFIED & todays_date <= FILE_MODIFIED + 10000
            temp_STR = STR(todays_date)
            ?(5) = VAL(MID(temp_STR,3,2))
            ?(4) = VAL(MID(temp_STR,5,2))
            ?(3) = VAL(RIGHT(temp_STR,2))
            STIME : RTIME
            STORE msg_pointer,  "Date, ",todays_date, " restored from EEPROM(0).": GOSUB LogMessage
        ELSE
            STORE msg_pointer,  "Invalid date, ",todays_date, " read from EEPROM(0).": GOSUB LogMessage
        ENDIF
    ENDIF
    RETURN
//------------------------------------------------------------------------------
//       ReadSetupIni
//          Reads setup3.ini file and sets variables accordingly
//          All variables are used locally except as they are set as per setup3.ini
//          lines in setup3.ini expected to be variable=value with no quotes or spaces around the =
//          Modified local variables temp_INT, i, command_done ...
//          Modified global variables: (many!)
ReadSetupIni:
    temp_STR = "^" // ^ is used as an obscure ASCII value not likely to be seen in .ini file
    i = 0
    data_file_ptr = DATA_PTR_BEGIN // Used to record size of file read, this portion of memory is not used between casts
    current_variable$ = ""   // LOCAL, Name of variable to be set
    data_reply$ = ""    // locally used, holds data parsed from data_file
    data_file$ = "setup3.ini" // locally used to hold file name to be read
    PRINT "Reading ",data_file$,"...";
    data_file_ptr = CFRead(data_file$,DFMAX,0,DATA_PTR_BEGIN)   // Read the contents of setup3.ini into data_file
    PRINT data_file$, "Read."
    IFF data_file_ptr > 0 // contents of data_file will now be in data_file
        pointer_address = ConvertVarPtr(temp_STR$) // Get our memory address
        STORE msg_pointer, "Initializing variables from ", data_file$, " file size: ",data_file_ptr : GOSUB LogMessage
        data_file_ptr = data_file_ptr + DATA_PTR_BEGIN // change from file length to end of data_file location
        FOR i = DATA_PTR_BEGIN to data_file_ptr
            temp_INT = GET(i) : i = i - 1 : command_done = 'F'
            POKE pointer_address + 1, temp_INT // We should now have the next character in temp_STR
            IF temp_STR = "\n" temp_STR = "^" // ignore new lines
            IFF temp_STR = "=" // Save variable name to current_variable when we get to a "="
                current_variable = data_reply
                data_reply$ = ""
                temp_STR = "^"
            ENDIF
            IFF temp_STR = "\r" | i = data_file_ptr // need to look for the last character even if it is not a CR
                GOSUB ParseVariables   // It's the end of the line so see if we can set this variable
            ENDIF
            IF temp_STR <> "^" data_reply = data_reply + temp_STR // build our string
        NEXT i
    ELSE
        temp_INT = data_file_ptr
        GOSUB GetCFerrorCodes // Get error code from temp_INT into temp_STR
        STORE msg_pointer, "Unable to read variable values from ", data_file$, ". ERROR: ", temp_STR : GOSUB LogMessage
    ENDIF
    data_file_ptr = DATA_PTR_BEGIN
    // Recalculate based on new values.
    IFF PROFILER_NUMBER <> VGET(1)
        VSTORE 1,PROFILER_NUMBER    // Store to EEPROM IF CHANGED
        STORE msg_pointer,  "Storing profiler number ",PROFILER_NUMBER, " to EEPROM(1)": GOSUB LogMessage
    ENDIF
    IF AVP_LIMIT_RELAY = 1 INRUSH_CLICKS = 8 : PRINT "INRUSH_CLICKS set to 8" // The relay board has more clicks/revolution
    DELTA_D_MIN! = .01 * FLOAT(DELTA_ERROR) * (FLOAT(DELTA_CLICKS) / FLOAT(CLICKS_PER_M)) // DELTA_ERROR% of expected travel. Will be recalculated from SETUP3.INI values
    temp_FLT = (FLOAT(DELTA_CLICKS) / FLOAT(CLICKS_PER_M))
    STORE msg_pointer, "INIT: Based on ",CLICKS_PER_M," cl/m and ",DELTA_ERROR,"% margin, min depth change/",#3D, DELTA_CLICKS, " clicks set to ", #5.3F, DELTA_D_MIN!," m" : GOSUB LogMessage
    IF ISCO_ENABLED GOSUB ISCOscheduleRead  // If we just enabled the ISCO, we need to read the schedule ASAP
    command_done = 'T'
    current_idle! = CHAN(7) * CURRENT_MULIPLIER! // re set the motor amps draw at rest.
    RETURN

ParseVariables:
    // Expects current_variable$, data_reply$
    // Sets command_done to 'T'
    // Clears data_reply$, temp_STR, current_variable$
    IF current_variable$ = "deBug"               deBug               = VAL(data_reply)  : command_done = 'T'
    IF current_variable$ = "PROFILER_LOCATION"   PROFILER_LOCATION$  =     data_reply$  : command_done = 'T'
    IF current_variable$= "LOOP_STARTUP_TIME"   LOOP_STARTUP_TIME   = VAL(data_reply$) : command_done = 'T'
    IF current_variable$ = "SYNC_TIME(0)"        SYNC_TIME(0)        = VAL(data_reply$) : command_done = 'T'
    IF current_variable$ = "SYNC_TIME(1)"        SYNC_TIME(1)        = VAL(data_reply$) : command_done = 'T'
    IF current_variable$ = "SYNC_TIME(2)"        SYNC_TIME(2)        = VAL(data_reply$) : command_done = 'T'
    IF current_variable$ = "SYNC_TIME(3)"        SYNC_TIME(3)        = VAL(data_reply$) : command_done = 'T'
    IF current_variable$ = "SYNC_TIME(4)"        SYNC_TIME(4)        = VAL(data_reply$) : command_done = 'T'
    IF current_variable$ = "SYNC_TIME(5)"        SYNC_TIME(5)        = VAL(data_reply$) : command_done = 'T'
    IF current_variable$ = "HOME_POSITION"       HOME_POSITION       = VAL(data_reply$) : command_done = 'T'
    IF current_variable$ = "CLICKS_PER_M"        CLICKS_PER_M        = VAL(data_reply$) : command_done = 'T'
    IF current_variable$ = "DELTA_CLICKS"        DELTA_CLICKS        = VAL(data_reply$) : command_done = 'T'
    IF current_variable$ = "HOME_TO_WL_COUNT"    HOME_TO_WL_COUNT    = VAL(data_reply$) : command_done = 'T'
    IF current_variable$ = "WL_TO_HOME_COUNT"    WL_TO_HOME_COUNT    = VAL(data_reply$) : command_done = 'T'
    IF current_variable$ = "AMPS_LOW"            AMPS_LOW!           = VAL(data_reply$) : command_done = 'T'
    IF current_variable$ = "AMPS_NORMAL"         AMPS_NORMAL!        = VAL(data_reply$) : command_done = 'T'
    IF current_variable$ = "AMPS_BOOSTED"        AMPS_BOOSTED!       = VAL(data_reply$) : command_done = 'T'
    IF current_variable$ = "PTC_CURRENT_MIN"     PTC_CURRENT_MIN!    = VAL(data_reply$) : command_done = 'T'
    IF current_variable$ = "PTC_CURRENT_MAX"     PTC_CURRENT_MAX!    = VAL(data_reply$) : command_done = 'T'
    IF current_variable$ = "LOW_VOLTAGE"         LOW_VOLTAGE!        = VAL(data_reply$) : command_done = 'T'
    IF current_variable$ = "DEPTH_PORT"          DEPTH_PORT          = VAL(data_reply$) : command_done = 'T'
    IF current_variable$ = "DEPTH_BAUD"          DEPTH_BAUD          = VAL(data_reply$) : command_done = 'T'
    IF current_variable$ = "DEPTH_MARGIN_M"      DEPTH_MARGIN_M!     = VAL(data_reply$) : command_done = 'T'
    IF current_variable$ = "water_depth_m"       water_depth_m!      = VAL(data_reply$) : command_done = 'T' // Assumed starting water depth.
    IF current_variable$ = "MIN_DEPTH_M"         MIN_DEPTH_M!        = VAL(data_reply$) : command_done = 'T'
    IF current_variable$ = "max_depth_m"         max_depth_m!        = VAL(data_reply$) : command_done = 'T'
    IF current_variable$ = "MAX_CAST_DEPTH_M"    MAX_CAST_DEPTH_M!   = VAL(data_reply$) : command_done = 'T'
    IF current_variable$ = "SALTWATER_COND"      saltwater_cond!     = VAL(data_reply$) : command_done = 'T' // For backwards compatibility.
    IF current_variable$ = "saltwater_cond"      saltwater_cond!     = VAL(data_reply$) : command_done = 'T'
    IF current_variable$ = "SMS_ADDRESS"         SMS_ADDRESS$        =     data_reply$  : command_done = 'T'
    IF current_variable$ = "LAUNCH_CHECK_CLICKS" LAUNCH_CHECK_CLICKS = VAL(data_reply$) : command_done = 'T'
    IF current_variable$ = "ENCODER_MAX_TIME"    ENCODER_MAX_TIME    = VAL(data_reply$) : command_done = 'T'
    IF current_variable$ = "ISCO_ENABLED"        ISCO_ENABLED        = VAL(data_reply$) : command_done = 'T'
    IF current_variable$ = "ISCO_SLEEP_TIME"     ISCO_SLEEP_TIME     = VAL(data_reply$) : command_done = 'T'
    IF current_variable$ = "PROFILER_NUMBER"     PROFILER_NUMBER     = VAL(data_reply$) : command_done = 'T'
    IF current_variable$ = "AVP_LIMIT_RELAY"     AVP_LIMIT_RELAY     = VAL(data_reply$) : command_done = 'T'
    IF current_variable$ = "AVP_SENSOR_CONFIG"   PRINT current_variable$," depricated." : command_done = 'T'
    IFF current_variable$ = "SONDE_FILTERING" // This one is a little different.
        IFF LEFT(data_reply,1) = "F" | LEFT(data_reply,1) = "0"
            SONDE_FILTERING = 0
        ELSE
            SONDE_FILTERING = 1
        ENDIF
        command_done = 'T'
    ENDIF
    // Now handle comments Comment lines begin with #
    IFF command_done = 'T'
        PRINT "      ",current_variable$," set to ", data_reply
    ELSE // this is to identify comments...
        IFF LEFT(data_reply,1) = "#" | LEFT(current_variable$,1) = "#"
            PRINT current_variable$,data_reply // this is a comment line
        ELSE
            STORE msg_pointer, "ERROR: Unable to process ",current_variable$," (", data_reply, ")" : GOSUB LogMessage
        ENDIF
        command_done = 'T'
    ENDIF
    data_reply$ = "" : temp_STR = "^" : current_variable$ = ""
    RETURN

CastCheck: // Checks if it is time to begin cast. Sets cast_status:
    IF cast_status >= 1 RETURN // this should make us cast immediately (1 = scheduled cast,2 = Cast ASAP)
    IF cast_count = 0 RETURN   // Don't check the time on the first cast while in console mode. This will also prevent a manual ISCO cast when cast_count = 0
    cast_status = 0           // Don't cast, yet. (0 = don't cast)
    RTIME
    FOR i = 0 to 5 // there are six schedule slots to test.
        FOR j = LOOP_STARTUP_TIME to 0 STEP -1
            temp_INT = ?(1) + j
            IF (temp_INT >= 60) temp_INT = temp_INT - 60  // This keeps the value between 0 and 59
            IF (SYNC_TIME(i) = temp_INT) cast_status = 1 : RETURN // Time for a scheduled cast
        NEXT j
    NEXT i
    // Not time to cast, but check the ISCO
    IF ISCO_ENABLED GOSUB ISCOcheck   // If it is time fo an ISCO casts, this will return cast_status = -1
    RETURN

LaunchCheck:
    // Check to see if we are in the water. This stops the cast if we have a jam or tangle.
    // This is only used while descending
    IFF sonde_depth! < SONDE_WL_MAX! | sonde_conduct! <= saltwater_cond! // We have a problem if we're not below 0.06 m or in salt water at this point.
        STORE msg_pointer, "ERROR: Launch or data error. Depth is ",#5.2F, sonde_depth!," after ", #04D, LAUNCH_CHECK_CLICKS, " clicks. Pausing to re-connect with sonde." : GOSUB LogMessage
        GOSUB MotorOff
        sonde_logging = 'F'  // Stop logging sonde data
        GOSUB StartSondeSampling // try to re-establish sonde communications
        temp_clicks = clicks_counted  // save click count
        IFF sonde_depth > 0.05 | sonde_conduct! > saltwater_cond!
            STORE msg_pointer, "Sonde comms re-established, resuming cast." : GOSUB LogMessage
            sonde_logging = 'T'  // Restart logging sonde data
            GOSUB MotorDown // if we got a good value, resume
        ELSE // Cast will exit since motor was not restarted
            STORE msg_pointer, "ERROR: Launch or data error, aborting cast." : GOSUB LogMessage
        ENDIF
        HPSleep(0) : HPSleep(10) // enough time for startup surge to pass
    ELSE
        clicks_counted = LAUNCH_CHECK_CLICKS + 1
        // Set the saltwater threshold to half the value a tthis depth.
        IF sonde_conduct! > 0 saltwater_cond! = sonde_conduct!/2.0
        IF deBug PRINT "At click ",clicks_counted," no launch problems detected. Conductivity target set to", #6.3F, saltwater_cond!,"."
    ENDIF
    RETURN

ResetWatchDogTimer: //Resets the watchdog timer. Must be done every 20 minutes or less.
    PSET 2                   // Set pin 2 high
    HPSleep(0) : HPSleep(25) // Wait 10 ms
    PCLR 2                   // Clear pin 2, re-enabling the watchdog
    RETURN

Stoppage:  // This is the clean up and stop the program routine.
    CtrlCReset()
    CBREAK StopNow
    PRINT : PRINT "PROGRAM SHUTDOWN"
    GOSUB MotorOff    // shut motor off
    STORE msg_pointer, "Ctrl-C received" : GOSUB LogMessage
    PRINT "Press ctrl-x to abort shutdown."
    FOR i = 10 to 1 STEP -1
        PRINT "   ",#2D,i,"      \r";
        IFF KbHit()
            key_pressed = KbChar()
            IFF key_pressed = 24
                CtrlCReset()
                STORE msg_pointer, "Shutdown Aborted" : GOSUB LogMessage
                CBREAK Stoppage
                cast_status = 0    // reset cast_status so we don't resume the cast.
                GOTO The_Main_Loop
            ENDIF
        ENDIF
        KbFlush()
        HPSleep(0) : HPSleep(50)
    NEXT i
    GOSUB StopSonde   // turn off the sond after turning off sampling
    GOSUB EncoderOff  // shut optical encoder off
    GOSUB PingerOff   // shut pinger off

StopNow:
    PCLR 2                   // Clear pin 2, re-enabling the watchdog
    PRINT "Closing Ports: ";
    PRINT "Wind IN(";
    temp_INT = TSerClose(WIND_IN_PORT) // close wind serial port
    IF temp_INT = 0 PRINT "Success) ";
    IF temp_INT = 1 PRINT "FAILED) ";
    PRINT ", Wind OUT(";
    temp_INT = TSerClose(WIND_OUT_PORT) // close wind serial port
    IF temp_INT = 0 PRINT "Success) ";
    IF temp_INT = 1 PRINT "FAILED) ";
    PRINT ", Depth(";
    temp_INT = TSerClose(DEPTH_PORT)  // Close depth port
    IF temp_INT = 0 PRINT "Success) ";
    IF temp_INT = 1 PRINT "FAILED) ";
    IFF TSerByteAvail(SONDE_IN_PORT) > 0  // Make sure that the sonde port is truly empty
        HPSleep(0):HPSleep(100)
        TSerInFlush(SONDE_IN_PORT)
    ENDIF
    PRINT ", Sonde In(";
    temp_INT = TSerClose(SONDE_IN_PORT)
    IF temp_INT = 0 PRINT "Success) ";
    IF temp_INT = 1 PRINT "FAILED) ";
    PRINT ", Sonde Out(";
    temp_INT = TSerClose(SONDE_OUT_PORT)
    IF temp_INT = 0 PRINT "Success) "
    IF temp_INT = 1 PRINT "FAILED) "
    STORE msg_pointer, "DONE" : GOSUB LogMessage
    VSTORE 5, 2  // Indicate that this was a planned shutdown
STOP

GetCFerrorCodes:
    // Errors codes for CFRead & CFSave
    // Expects temp_INT returns temp_STR
    temp_STR = "unknown error"
    IF temp_INT = -1 temp_STR = "CF init failed"
    IF temp_INT = -2 temp_STR = "Invalid filename"
    IF temp_INT = -3 temp_STR = "Can't open file"
    IF temp_INT = -4 temp_STR = "Can't position to the requested offset"
    RETURN

ClearSched:
    FOR i = 0 to 5
       SYNC_TIME(i) = 99    // Set all SYNC_TIME() entries to 99.
    NEXT i
    STORE msg_pointer, "Schedule Cleared, reboot or re-init to resume casting." : GOSUB LogMessage
    RETURN

ErrorCheck:
    STORE msg_pointer, "Error #", temp_INT/65536," found at token address ", #1H, temp_INT % 65536, " (hex)" : GOSUB LogMessage
    temp_STR = "Unknown."
    //IF temp_INT/65536 = 1 temp_STR =   "Not used in TxBASIC"
    IF temp_INT/65536 = 2 temp_STR =   "Array variable index out of range"
    //IF temp_INT/65536 = 3 temp_STR =   "Not used in TxBASIC"
    IF temp_INT/65536 = 4 temp_STR =   "STORE out of range of the datafile"
    IF temp_INT/65536 = 5 temp_STR =   "GET out of range of the datafile"
    IF temp_INT/65536 = 6 temp_STR =   "Integer divide by zero"
    IF temp_INT/65536 = 7 temp_STR =   "Integer multiply overflow"
    //IF temp_INT/65536 = 8 temp_STR =   "Not used in TxBASIC"
    IF temp_INT/65536 = 9 temp_STR =   "Integer add or subtract overflow"
    //IF temp_INT/65536 = 10 temp_STR =  "Integer ABS argument = 2147483648"
    IF temp_INT/65536 = 11 temp_STR =  "A-D channel not supported"
    IF temp_INT/65536 = 12 temp_STR =  "I/O pin not supported"
    //IF temp_INT/65536 = 13 temp_STR =  "Not used in TxBASIC"
    //IF temp_INT/65536 = 14 temp_STR =  "Input to TEMP out of range"
    //IF temp_INT/65536 = 15 temp_STR =  "Not used in TxBASIC"
    //IF temp_INT/65536 = 16 temp_STR =  "SDI requested <1 or > 32 bits"
    IF temp_INT/65536 = 17 temp_STR =  "COUNT time-out > 65535"
    //IF temp_INT/65536 = 18 temp_STR =  "Bad PERIOD argument"
    //IF temp_INT/65536 = 19 temp_STR =  "Not used in TxBASIC"
    //IF temp_INT/65536 = 20 temp_STR =  "Not used in TxBASIC"
    //IF temp_INT/65536 = 21 temp_STR =  "Not used in TxBASIC"
    IF temp_INT/65536 = 22 temp_STR =  "Datafile out of range (Off-load only)"
    //IF temp_INT/65536 = 23 temp_STR =  "OFFLD time-out > 65535"
    IF temp_INT/65536 = 24 temp_STR =  "SLEEP interval > 32767"
    //IF temp_INT/65536 = 25 temp_STR =  "USEND/UGET baud rate out of range"
    IF temp_INT/65536 = 26 temp_STR =  "ITEXT time-out > 65535"
    //IF temp_INT/65536 = 27 temp_STR =  "TONE parameter out of range"
    //IF temp_INT/65536 = 28 temp_STR =  "XSHAKE time-out > 65535"
    //IF temp_INT/65536 = 29 temp_STR =  "Date/time input to STIME out of range"
    //IF temp_INT/65536 = 30 temp_STR =  "Integer input to RTIME out of range"
    //IF temp_INT/65536 = 31 temp_STR =  "HYB internal > 65535"
    //IF temp_INT/65536 = 32 temp_STR =  "SDO requested <1 or > 32 bits"
    //IF temp_INT/65536 = 33 temp_STR =  "CALL address > 65535"
    //IF temp_INT/65536 = 34 temp_STR =  "Not used in TxBASIC"
    //IF temp_INT/65536 = 35 temp_STR =  "Not used in TxBASIC"
    //IF temp_INT/65536 = 36 temp_STR =  "VSTORE/VGET index out of range"
    //IF temp_INT/65536 = 37 temp_STR =  "UGET time-out > 65535"
    IF temp_INT/65536 = 38 temp_STR =  "STIME out of range"
    //IF temp_INT/65536 = 39 temp_STR =  "Not used in TxBASIC"
    //IF temp_INT/65536 = 40 temp_STR =  "PRINT {x,y}; where y < x"
    //IF temp_INT/65536 = 41 temp_STR =  "PRINT field width > 255"
    //IF temp_INT/65536 = 42 temp_STR =  "INT or FIX result overflow"
    //IF temp_INT/65536 = 43 temp_STR =  "OFFLD x,y; where x > y"
    //IF temp_INT/65536 = 44 temp_STR =  "PIN number out of range"
    //IF temp_INT/65536 = 45 temp_STR =  "Not used in TxBASIC"
    //IF temp_INT/65536 = 46 temp_STR =  "Attempt to RUN a second background task"
    //IF temp_INT/65536 = 47 temp_STR =  "Array index out of bounds"
    //IF temp_INT/65536 = 48 temp_STR =  "DFSAVE, DFREAD out of bounds"
    //IF temp_INT/65536 = 49 temp_STR =  "RATE 0 attempted"
    //IF temp_INT/65536 = 50 temp_STR =  "ADLOOP address out of range"
    IF temp_INT/65536 = 51 temp_STR =  "Stack running low"
    //IF temp_INT/65536 = 52 temp_STR =  "Not used in TxBASIC"
    IF temp_INT/65536 = 53 temp_STR =  "Disk command: datafile wrong size"
    STORE msg_pointer, "ERROR: ", temp_STR," Attempting to re-enter main loop." : GOSUB LogMessage
GOTO The_Main_Loop
//------------------------------------------------------------------------------

//------------------------------------------------------------------------------
//       ISCO Control Section
//
//                    ISCOscheduleRead
//                    ISCOcheck
//                    ISCOcast
//                    ISCOrun
//                    ISCOmessage
//------------------------------------------------------------------------------
//       ISCOscheduleRead
//          Reads ISCO_FILE file and puts the contents in the ISCO_sched array.
//          ISCO_LOG_FILE is a comma delimited text file. It has 4 fields and up to ISCO_MAX_BOTTLES records.
//             The fields are: bottle number, date (yyyymmdd), time (hhMM), and depth in cm (NOT meters).
//          The ISCO_sched array is ISCO_MAX_BOTTLES x 2 with two values (date & depth).
//          This routine expects up to ISCO_MAX_BOTTLES bottles. The array number (+1) is the bottle number.
//
// ISCO_bottle = VGET(2)   // Current Bottle Number
ISCOscheduleRead:
    GOSUB ISCOClearSched
    msg_log_file$ = ISCO_LOG_FILE$
    data_file_ptr = DATA_PTR_BEGIN // Used to record size of file read, this portion of memory is not used between casts
    data_reply$ = ""    // locally used, holds data parsed from data_file
    //ISCO_bottle = 0     // Should be set to (1-ISCO_MAX_BOTTLES,99,-99)
    STORE msg_pointer,  "Reading ISCO sched" : GOSUB LogMessage
    data_file_ptr = CFRead(ISCO_FILE$,DFMAX,0,DATA_PTR_BEGIN)   // Read the contents of ISCO_FILE into data_file
    IFF data_file_ptr > 0 // log_data_pty bytes of ISCO_FILE$ will now be in the data file starting at DATA_PTR_BEGIN
        temp_STR = "^" // ^ is used as an obscure ASCII value not likely to be seen in .ini file
        pointer_address = ConvertVarPtr(temp_STR$) // Get our memory address
        STORE msg_pointer, "   Initializing Variables from ", ISCO_FILE$ //, " file size: ",data_file_ptr  :
        GOSUB LogMessage
        data_file_ptr = DATA_PTR_BEGIN + data_file_ptr // change from file length to end of data_file location
        FOR i = DATA_PTR_BEGIN to data_file_ptr // This is iterates through every character in the file
            temp_INT = GET(i) : i = i - 1
            POKE pointer_address + 1, temp_INT // The current character is now in temp_STR
            // Grab one line at a time and then parse the line
            IF temp_STR = "\n" temp_STR = "" // ignore new lines
            IF temp_STR = " "  temp_STR = ""  // ignore spaces
            IFF temp_STR = "\r" | i = data_file_ptr // need to look for the last character even if it is not a CR
                IFF INSTR(data_reply$,",") > 0       // We are at the end of a line so we should now parse the line
                    ISCO_bottle = VAL(LEFT(data_reply$,INSTR(data_reply$,",") - 1)) // The characters before the first comma
                    IF deBug PRINT "Parsing bottle ", ISCO_bottle
                    IFF ISCO_bottle >= 1 & ISCO_bottle <= ISCO_MAX_BOTTLES
                        IF deBug PRINT "   Bottle ",#02D, ISCO_bottle;
                        data_reply$ = RIGHT(data_reply$, LEN(data_reply$) - INSTR(data_reply$,",")) // This should remove everything up to the first comma
                        ISCO_sched(ISCO_bottle - 1,0) = VAL(LEFT(data_reply$,8)) // the Date is now first 6 characters
                        IF deBug PRINT " Date ",#08D, ISCO_sched(ISCO_bottle - 1,0);
                        data_reply$ = RIGHT(data_reply$,LEN(data_reply$) - INSTR(data_reply$,",")) // This should remove everything up to the second comma
                        ISCO_sched(ISCO_bottle - 1,1) = VAL(LEFT(data_reply$,4)) // the Time is now the first 4 characters
                        IF deBug PRINT " Time ",#04D, ISCO_sched(ISCO_bottle - 1,1);
                        data_reply$ = RIGHT(data_reply$,LEN(data_reply$) - INSTR(data_reply$,",")) // This should remove everything up to the third comma
                        ISCO_sched(ISCO_bottle - 1,2)  = VAL(data_reply$) //depth is whatever remains
                        IF deBug PRINT " Depth ",#3D, ISCO_sched(ISCO_bottle - 1,2)," (cm)" // Note that this is in cm not m
                    ELSE
                        IF deBug PRINT " ERROR, ",ISCO_bottle, " is out of range 1 - ",ISCO_MAX_BOTTLES
                        ISCO_bottle = 0
                    ENDIF
                ENDIF
                data_reply$ = "" : temp_STR = " "
            ELSE
                data_reply$ = data_reply$ + temp_STR    // Append this character to the string (data_reply) we are building
                temp_STR = " "
            ENDIF
        NEXT i
        IF deBug PRINT "ISCO schedule read."
        // Now see which bottle is next
        GOSUB ISCOscheduleProcess
    ELSE // We had a file open error
        temp_INT = data_file_ptr // Put the errorcode into temp_INT
        GOSUB GetCFerrorCodes // Get error code from temp_INT into temp_STR
        msg_log_file$ = ""
        STORE msg_pointer, "   Could not open ",ISCO_FILE$,". ERROR: ",temp_STR, ". ISCO Disabled. Run 'init' command to re-enable.": GOSUB LogMessage
        GOSUB ISCOClearSched  // Clear schedule and set ISCO_bottle to 0
        //ISCO_ENABLED = 0
    ENDIF
    IFF ISCO_bottle >= 1 & ISCO_bottle <= ISCO_MAX_BOTTLES
        STORE msg_pointer, "Bottle ",ISCO_bottle," is next." : GOSUB LogMessage
    ELSE
        STORE msg_pointer, "Invalid Bottle # (",ISCO_bottle,"). Bottles are either all full, or there is no schedule." : GOSUB LogMessage
    ENDIF
    msg_log_file$ = ""
    RETURN

ISCOscheduleProcess:
    // Figure out where in the process we are.
    ISCO_bottle = -99  //Used as a flag in the FOR NEXT loop.
    RTIME : temp_FLT! = (?(2)*100 + ?(1)) // Store the current time
    FOR i = 23 to 0 step -1 // Count from last to first bottles
        IFF todays_date = ISCO_sched(i,0)   // See if the first cast is today
            IFF temp_FLT! <= ISCO_sched(i,1) // Now compare times
                ISCO_bottle = i + 1
                STORE msg_pointer,   "Bottle ",ISCO_bottle," is later today! (",ISCO_sched(i,1)," >= ",#4.0F,temp_FLT,")" : GOSUB LogMessage
            ELSE
                ISCO_bottle = ABS(ISCO_bottle) // this shouldn't change much
                STORE msg_pointer, "Sample time (",#4D,ISCO_sched(i,1),") for bottle ",#2D,i+1," was today (",#8D,ISCO_sched(i,0),") but has passed. Still on bottle ",#2D, ISCO_bottle : GOSUB LogMessage
            ENDIF
        ENDIF
        IFF todays_date < ISCO_sched(i,0)
            // this is a cast on a future date, but could be our next cast
            ISCO_bottle = i + 1
            IF deBug PRINT "Bottle ",ISCO_bottle," is in the future! (",ISCO_sched(i,0)," > ",todays_date,")"
        ENDIF
        IFF todays_date > ISCO_sched(i,0) & deBug
            PRINT "Sample date (",ISCO_sched(i,0),") for bottle ",i+1," has passed"
            IF ISCO_bottle = -99 ISCO_bottle = 99 // indicates that a bottle has been parsed, but is past
        ENDIF
    NEXT i
    IFF ABS(ISCO_bottle) > ISCO_MAX_BOTTLES
        // This is an invalid bottle number, but will indicate either all the bottles are full, or
        //    there is no schedule.
        IF (ISCO_bottle = 99)  ISCO_bottle = 0 : STORE msg_pointer, "   All sample dates have passed." : GOSUB LogMessage
        IF (ISCO_bottle = -99) ISCO_bottle = 0 : STORE msg_pointer, "   No samples parsed" : GOSUB LogMessage
    ENDIF
    IF deBug PRINT "Storing bottle number ", ISCO_bottle ," to EEPROM(2)."
    VSTORE 2,ISCO_bottle
    RETURN

ISCOClearSched:
    FOR i = 0 to ISCO_MAX_BOTTLES    // Clear out ISCO_sched array.
        FOR j = 0 to 2
            ISCO_sched(i,j) = 0
        NEXT j
    NEXT i
    ISCO_bottle = 0
    VSTORE 2,ISCO_bottle
    IF deBug PRINT "ISCO schedule cleared"
    RETURN
//------------------------------------------------------------------------------
//       ISCOcheck
//          Check array to see if it is time to cast
//          Can be called through console
//          Sets cast_status = -1 if it is time for an isco cast
ISCOcheck:
    ISCO_bottle = VGET(2)
    IFF ISCO_bottle >= 1 & ISCO_bottle <= ISCO_MAX_BOTTLES // Make sure we're in range so we don't crash. (changed from | to &)
        IF (ISCO_sched(ISCO_bottle - 1,0) < todays_date)  cast_status = -1 : RETURN // We missed it, so do it now!
        IFF ISCO_sched(ISCO_bottle - 1,0) = todays_date  // There's a cast today...
           RTIME
           IF (ISCO_sched(ISCO_bottle - 1,1) <= (?(2)*100 + ?(1)))  cast_status = -1 : RETURN // It's time to cast!
        ENDIF
    ENDIF
    RETURN
//------------------------------------------------------------------------------
//       ISCOcast
//          We will perform an ISCO cast.
//          If cast_status = -2 this is a manual cast and so we won't do any of
//             the routines to get the sonde to the correct depth.
ISCOcast:
    GOSUB GetDate  // Get the date which will be used for all file names during this cast.
    ISCO_bottle = VGET(2)  // Get current bottle number from EEPROM
    cast_mode$ = "ISCO Cast: "
    // Lower to the desired depth
    IFF cast_status = -1 // A standard ISCO cast
        // Turn on encoder, sonde
        sonde_logging = 'F'
        GOSUB StartSondeSampling
        GOSUB EncoderOn
        voltage_idle! = CHAN(6) : voltage_idle! = (CHAN(6)/4369.0) + 1.7 // Charge up a/d from voltage divider then record actual voltage
        // Log the ISCO cast
        STORE msg_pointer, "ISCO: ------- Initiating automatic ISCO Cast for Bottle ", ISCO_bottle, " on ",SONDE_ID,". Bat at ", #4.1F,voltage_idle, " Volts"
        GOSUB ISCOmessage
        IFF sonde_depth! <= REHOME_DEPTH! & sonde_conduct! <= saltwater_cond! // We are out of the water
            // Get us in the water
            depth_target! = SONDE_WL_MIN!
            clicks_desired = HOME_TO_WL_COUNT
            check_cond = 1 // If we check conductivity we'll stop too high.
            // check_WL = 1 this does nothing on decent as of 3.15
            GOSUB MotorRun
        ENDIF
        // Set our targets. Remember that the depth array is in cm not m
        // This was having a INT to FLT conversion problem, so I added the temp_FLT! step. This remains to be tested.
        depth_target! = ISCO_sched(ISCO_bottle - 1, 2)/100.0
        IFF depth_target! > MAX_CAST_DEPTH_M! // Don't let us cast further than is reasonable.
            depth_target! = MAX_CAST_DEPTH_M!
        ENDIF
        clicks_desired = INT((depth_target! - sonde_depth!) * CLICKS_PER_M) // IS THIS TOO FEW CLICKS?
        IF clicks_desired < 0 STORE msg_pointer, "ISCO: Raising sonde until depth <";
        IF clicks_desired > 0 STORE msg_pointer, "ISCO: Lowering sonde until depth >";
        STORE msg_pointer, " ",#3D,ISCO_sched(ISCO_bottle - 1,2), " cm or until ",#3D, clicks_desired," clicks." : GOSUB ISCOmessage
        // If our sample depth is near the surface, we may not need a second move
        GOSUB MotorRun
        GOSUB ISCOrun // Start the ISCO sampling and wait for it to finish. Increment ISCO_bottle, mark cast done.
        GOSUB ISCOcheck  // If we need another sample at a deeper depth, get it now
        IF cast_status = 0 GOSUB ParkSonde // We're done with our cast.
        IF cast_status = -1 GOSUB ISCOcast // This gets a bit recursive, but it should all work out once cast_status = 0
    ENDIF
    IFF cast_status = -2   // This is a manual ISCO sample to be taken at the current depth.
        IF ISCO_bottle = 0 ISCO_bottle = 1 // If there is no schedule, might as well start one.
        voltage_idle! = CHAN(6) : voltage_idle! = (CHAN(6)/4369.0) + 1.7 // Charge up a/d from voltage divider then record actual voltage
        // Log the ISCO cast to both log files.
        // Make sure that ISCO_bottle is in range.
        STORE msg_pointer, "INIT: ------- Initiating manual ISCO Cast for Bottle ", ISCO_bottle, " on ",SONDE_ID,". Bat at ", #4.1F,voltage_idle, " Volts"
        GOSUB ISCOmessage
        depth_target! = sonde_depth!  // Our depth target is where we are now.
        FOR i = ISCO_MAX_BOTTLES to ISCO_bottle STEP -1  // This would mess up the bottle number in the schedule, but pop off the last scheduled isco sample and insert the current sample.
            ISCO_sched(i - 1,0) = ISCO_sched(i - 2,0) // Increment the date
            ISCO_sched(i - 1,1) = ISCO_sched(i - 2,1) // Increment the time
            ISCO_sched(i - 1,2) = ISCO_sched(i - 2,2) // Increment the depth
        NEXT i
        // Now put the current values in for our current bottle
        RTIME
        ISCO_sched(ISCO_bottle - 1,0) = todays_date
        ISCO_sched(ISCO_bottle - 1,1) = (?(2) * 100 ) + ?(1)
        ISCO_sched(ISCO_bottle - 1,2) = INT(depth_target! * 100)
        // Finally, create a new schedule file based on this change
        msg_pointer = 0
        FOR i = 0 to ISCO_MAX_BOTTLES - 1
            STORE msg_pointer, "",i+1,",",ISCO_sched(i,0),",", ISCO_sched(i,1),",", ISCO_sched(i,2)
        NEXT i
        temp_INT = CFSave(ISCO_FILE$, msg_pointer - 1, 0, 0)
        IFF temp_INT < 1
            GOSUB GetCFerrorCodes // Get error code from temp_INT into temp_STR
            STORE msg_pointer, "Failed to update ", ISCO_FILE$, " ERROR: ",temp_STR : GOSUB ISCOmessage
        ELSE
            STORE msg_pointer, "Updated ", temp_INT, " bytes of schedule:", ISCO_FILE$ : GOSUB ISCOmessage
        ENDIF
        GOSUB ISCOrun // Start the ISCO sampling and wait for it to finish. Increment ISCO_bottle, mark cast done.
    ENDIF
    msg_log_file$ = ""
    RETURN
//------------------------------------------------------------------------------
//       ISCOrun
//          Set pin 1 high to signal ISCO to start sampling
//          Wait until ISCO is done
//          Log bottle, start date,start time, depth. Increment bottle number
ISCOrun:
    //IF deBug PRINT "Getting updated depth from sonde."
    //GOSUB GetSondeDepth
    STORE msg_pointer, "ISCO: Sampling to bottle ",ISCO_bottle, " at ", #6.3F, sonde_depth!, " m" : GOSUB ISCOmessage
    PSET(1)
    HPSleep(0) : HPSleep(2000) // Sleep long enough for the purge cycle to begin.
    PCLR(1)
    voltage_load! = CHAN(6) : voltage_load! = (CHAN(6)/4369.0) + 1.7 // Charge up a/d from voltage divider then record actual voltage
    // Log end date, end time
    STORE msg_pointer, "ISCO: Load Voltage ",#5.2F,voltage_load! : GOSUB ISCOmessage
    // wait for ISCO to finish
    GOSUB ResetWatchDogTimer
    IF deBug PRINT "Waiting fo ISCO ";
    FOR i = ISCO_SLEEP_TIME TO 0 STEP -1
        SLEEP 0
        IF deBug PRINT i," ";
        // If we're going to log some sonde data, here is the place to do it.
        //IF i = 60 & deBug PRINT "\nWe could be logging sonde data here if we wanted that functionality. "
        SLEEP 100
    NEXT i
    IF deBug PRINT
    // Log end date, end time
    GOSUB GetSondeDepth
    STORE msg_pointer, "ISCO: Done with bottle ", ISCO_bottle, " at ",#5.3F, sonde_depth!, " m" : GOSUB ISCOmessage
    // Log appropriate message.
    IFF ISCO_bottle = ISCO_MAX_BOTTLES // We just filled the last bottle.
        //ISCO_ENABLED = 0 // Disable ISCO
        sms_msg$ = sms_msg$ + "ISCO: All " + STR(ISCO_MAX_BOTTLES) + " bottles full (" + STR(ISCO_bottle) + ")."
        STORE msg_pointer, "",sms_msg$ : GOSUB ISCOmessage
        GOSUB CheckSMS
        GOSUB ISCOClearSched
    ELSE // This was a valid bottle so increment to the next bottle.
        // Increment the bottle number and store it
        ISCO_bottle = ISCO_bottle + 1
        VSTORE 2,ISCO_bottle
        STORE msg_pointer, "ISCO: Next bottle is ", ISCO_bottle, " at ",ISCO_sched(ISCO_bottle-1,1)," on ", ISCO_sched(ISCO_bottle-1,0)  : GOSUB ISCOmessage
    ENDIF
    cast_status = 0 // We are done with the cast now so reset flag
    RETURN
//------------------------------------------------------------------------------
//       ISCOmessage
//          Logs the date, time and message to ISCO_LOG_FILE$
ISCOmessage:
    msg_log_file$ = ISCO_LOG_FILE$
    msg_begin = 1
    RTIME
    STORE msg_begin,"20",#02,?(5),"/",?(4),"/",?(3)," ",?(2),":",?(1),":",?(0)," ";  // Store Date to Data File
    msg_begin = 1
    previous_pointer = msg_pointer //Store msg_pointer here
    GOSUB LogContinue
    msg_pointer = previous_pointer // Restore Message
    GOSUB LogMessage
    RETURN
//-------------END ISCO Routines----------------------------------------------------------------


TrimStr:
    // Takes a variable data_send_str and temp_INT
    // Returns data_reply
    // Performs the following actions on temp_STR:
    // temp_INT = 1 -> LTRIM
    // temp_INT = 2 -> RTRIM
    // temp_INT = 3 -> ALLTRIM
    i = 0 // Length of working string
    j = 0 // Ascii value of current character.
    data_reply$ = ""
    temp_STR = "A"
    pointer_address = ConvertVarPtr(temp_STR$)   // find the address of this variable
    IFF temp_INT = 1 | temp_INT = 3 // Do the left trim
        REPEAT
            temp_STR = LEFT(data_send_str,1)
            j =  PEEK(pointer_address + 1)     // get the contents of variable in decimal
            IFF j < 33
               i = LEN(data_send_str$)
               data_send_str$ = RIGHT(data_send_str$,i - 1)
            ENDIF
        UNTIL j >= 33
    ENDIF
    IFF temp_INT = 2 | temp_INT = 3  // Do the right trim
        REPEAT
            temp_STR = RIGHT(data_send_str,1)
            j =  PEEK(pointer_address + 1)     // get the contents of variable in decimal
            IFF j < 33
                i = LEN(data_send_str$)
                data_send_str$ = LEFT(data_send_str$,i - 1)
            ENDIF
        UNTIL j >=33
    ENDIF
    data_reply$ = data_send_str$   // Now put the value into data_reply
    RETURN
